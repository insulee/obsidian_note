- `![0046!]`: 표출_신호_스케쥴_작성
- `![0045!]`: 표출_신호_패턴 읽기
- `![0044 S16D1T1C0I0W16P0_a16!]`: 표출_신호_패턴 쓰기

# HUB75 표출신호 패턴 문자열 작성 가이드

## 개요

HUB75 LED 모듈의 표출신호 패턴 문자열은 LED 픽셀들이 어떤 순서와 방향으로 점등되는지를 정의하는 문자열입니다. 이 가이드는 패턴 문자열을 올바르게 작성하는 방법을 단계별로 설명합니다.

## 기본 구조

패턴 문자열은 다음과 같은 구조를 가집니다:

```
[헤더]_[패턴]
```

**예시:**

```
S04D1T1C0I0W64P0_a16
```

- 헤더: `S04D1T1C0I0W64P0`
    
- 패턴: `a16`
    
- **헤더**: 하드웨어 특성 정의 (Duty, 데이터라인 등)
    
- **패턴**: 실제 픽셀 매핑 순서 정의
    

---

## 헤더 구문 작성법

### 헤더 형식

```
SnnDnTnCnInWnn[Pn]_
```

헤더는 하드웨어 특성을 정의하는 파라미터들로 구성됩니다.

### 파라미터별 상세 설명

| 파라미터    | 의미                | 값 범위                   | 예시  | 설명                                      |     |
| ------- | ----------------- | ---------------------- | --- | --------------------------------------- | --- |
| **Snn** | 스캔 비율 (1/nn 스캔)   | 01, 02, 04, 08, 16, 32 | S16 | 1/16 스캔 방식                              |     |
| **Dn**  | 데이터 라인 수          | 1, 2                   | D1  | D1단일 데이터 라인<br>D2는 이중 데이터 라인            |     |
| **Tn**  | 주소 디코더 IC 타입      | 0–4                    | T1  | 디코더 IC 타입 선택(아래 T 파라미터 표 참조)            |     |
| **Cn**  | RGB 색상 순서         | 0–6                    | C0  | RGB 순서다른 값은 색상 순서 변경                    |     |
| **In**  | 드라이버 IC 타입        | 0–9                    | I0  | 일반 드라이버추후 확장 예정                         |     |
| **Wnn** | 단일 데이터 라인 제어 픽셀 수 | 16–128                 | W32 | 1개 데이터 라인이 1스캔에 제어하는 픽셀 수               |     |
| **Pn**  | 비표준 모듈 식별자        | 0–9 (선택)               | P0  | P0: 표준 HUB75P1~P9: 스캔 방식/커넥터가 완전히 다른 모듈 |     |

#### T 파라미터 상세 (주소 디코더 IC 타입)

| 값   | IC 타입               | 적용 사례                   |
| --- | ------------------- | ----------------------- |
| T0  | 디코더 IC 없음           | 1/4 duty와 1/2 duty      |
| T1  | 74HC138 정방향         | 일반적인 디코더 IC             |
| T2  | 74HC138 역방향         | Vissem 3Color 1/16 duty |
| T3  | 74HC595 (SUM2017TD) | 1/8 duty 적용             |
| T4  | L800                | 1/4 duty 적용             |

### 파라미터 작성 예시

#### 기본 모듈 설정

```javascript
// 32×16 LED 모듈 (1/4 스캔, 단일 데이터라인)
"S04D1T1C0I0W32P0_패턴";

// 64×32 LED 모듈 (1/2 스캔, 이중 데이터라인)
"S02D2T1C0I0W64P0_패턴";

// 128×64 LED 모듈 (1/2 스캔, 이중 데이터라인)
"S02D2T1C0I0W128P0_패턴";
```

#### 특수 모듈 설정

```javascript
// P1: 32 duty 2단 패턴 (스캔 방식이 다른 모듈)
"S32D1T1C0I0W16P1_패턴"; // P1: 2단 모듈, 표준과 다른 스캔 방식

// P2: 16 duty 4단 4열 (스캔 방식이 다른 모듈)
"S16D1T1C0I0W128P2_패턴";

// P3~P7: 커넥터/스캔 방식이 완전히 다른 모듈들
"S08D2T1C0I0W16P3_패턴"; // Vissem 3Color 8D
```

### 중요 사항

#### W 파라미터 계산법

**W 값**은  입니다.

**핵심 원리**: 동일한 duty라도 데이터 라인 수에 따라 픽셀 처리 부담이 분산됩니다.

##### Duty별 W값 계산표

| Duty     | D1 (단일 라인)     | D2 (이중 라인)    | 설명                                               |
| -------- | -------------- | ------------- | ------------------------------------------------ |
| **1/32** | W16 (P1만)      | –             | P1 비표준 모듈만 존재 (2단 모듈)                            |
| **1/16** | W16 (P0 2단 모듈) | W8 (P0 1단 모듈) | 2단 모듈: D1+P0 표준1단 모듈: D2+P0 특수 설정4단 4열: P2 특수 모듈 |
| **1/8**  | W32            | W16           | 32픽셀을 1개/2개 라인으로 분산                              |
| **1/4**  | W64            | W32           | 64픽셀을 1개/2개 라인으로 분산                              |
| **1/2**  | W128           | W64           | 128픽셀 을 1개/2개 라인으로 분산                            |

##### 실제 계산 예시

```javascript
// 1/32 Duty 특별 처리 (P1 비표준 모듈 - 스캔 방식이 다름)
"S32D1T1C0I0W16P1_패턴"; // P1: 2단 모듈, 표준과 다른 스캔 방식

// 1/16 Duty 다양한 모듈 타입 및 디코더 IC
"S16D1T1C0I0W16P0_패턴"; // 2단 모듈: D1+P0 표준 (74HC138 정방향)
"S16D2T1C0I0W16P0_패턴"; // 1단 모듈: D2+P0 특수 설정 (74HC138 정방향)
"S16D1T2C0I0W16P0_패턴"; // Vissem 1/16 duty (74HC138 역방향)
"S16D1T1C0I0W128P2_패턴"; // 4단 4열: P2 특수 모듈

// 1/8 Duty 32×16 모듈 및 디코더 IC
"S08D1T1C0I0W32P0_패턴"; // 단일 라인, 74HC138 정방향
"S08D2T0C0I0W16P0_패턴"; // 이중 라인, 디코더 IC 없음
"S08D2T3C0I0W16P0_패턴"; // 74HC595(SUM2017TD) - 현재 1/8 duty에 적용

// 1/4 Duty 32×16 모듈 및 디코더 IC
"S04D1T1C0I0W64P0_패턴"; // 단일 라인, 74HC138 정방향
"S04D2T1C0I0W32P0_패턴"; // 이중 라인, 74HC138 정방향
"S04D2T4C0I0W32P0_패턴"; // L800 디코더 - 현재 1/4 duty에 적용

// 1/2 Duty 64×32 모듈
"S02D1T1C0I0W128P0_패턴"; // 단일 라인이 128픽셀 처리
"S02D2T1C0I0W64P0_패턴"; // 각 라인이 64픽셀씩 처리 (128÷2=64)
```

##### 모듈 수 계산 공식

**간단한 계산법:**

- **P0 표준 모듈**: W 값은 하드웨어 사양에 따라 자동 결정
    
- **P1~P9 비표준 모듈**: 스캔 방식/커넥터가 다른 모듈의 특별 계산
    

**실제 사용법**:

1. 사용할 LED 모듈의 사양서 확인
    
2. Duty 타입과 데이터 라인 수에 맞는 W 값을 선택
    
3. **T 파라미터 선택 (디코더 IC 타입)**:
    
    - 디코더 IC 없음 → T0
        
    - 74HC138 정방향 → T1 (일반적)
        
    - 74HC138 역방향 → T2 (Vissem 1/16 duty)
        
    - 74HC595(SUM2017TD) → T3 (현재 1/8 duty에 적용)
        
    - L800 → T4 (현재 1/4 duty에 적용)
        
4. **P 파라미터 선택**:
    
    - 표준 HUB75 모듈 → P0 (생략 가능)
        
    - 스캔 방식이 완전히 다른 모듈 → P1~P9
        
    - 커넥터가 HUB75가 아닌 모듈 → P1~P9
        
5. **1/16 duty 모듈별 선택법**:
    
    - 2단 모듈 → `S16D1...P0` (표준)
        
    - 1단 모듈 → `S16D2...P0` (특수 설정)
        
    - 4단 4열 모듈 → `S16D1...P2` (특수 모듈)
        

**예시**:

```javascript
// 일반적인 32×16 모듈 (1/4 duty, 74HC138 정방향)
"S04D2T1C0I0W32P0_패턴"; // 이중 데이터라인

// 디코더 IC별 선택법
"S08D2T0C0I0W16P0_패턴"; // 디코더 IC 없음
"S04D2T1C0I0W32P0_패턴"; // 74HC138 정방향 (일반적)
"S16D1T2C0I0W16P0_패턴"; // 74HC138 역방향 (Vissem)
"S08D2T3C0I0W16P0_패턴"; // 74HC595(SUM2017TD) - 현재 1/8 duty에 적용
"S04D2T4C0I0W32P0_패턴"; // L800 디코더 - 현재 1/4 duty에 적용

// 16×16 모듈 선택법 (1/16 duty) - 모듈 타입에 따라 다름
"S16D1T1C0I0W16P0_패턴"; // 2단 모듈인 경우
"S16D2T1C0I0W16P0_패턴"; // 1단 모듈인 경우
"S16D1T1C0I0W128P2_패턴"; // 4단 4열 모듈인 경우

// 특수 2단 모듈 (1/32 duty)
"S32D1T1C0I0W16P1_패턴"; // P1 비표준 모듈 (스캔 방식이 다름)
```

#### P 파라미터 사용법

- **P0**: 표준 HUB75 규격 (생략 가능)
    
- **P1~P9**: 비표준 모듈 - 다음 경우에만 사용:
    
    - 스캔 방식이 기존 방식과 완전히 다른 경우
        
    - 커넥터 타입이 HUB75가 아닌 경우
        
- **중요**: P1~P9 모듈도 헤더 작성법(`SnnD?T?C?I?Wnn`)은 표준과 동일
    
- P 파라미터를 생략하면 자동으로 P0으로 처리됩니다
    

#### 올바른 헤더 예시

```javascript
✅ "S04D1T1C0I0W64P0_a16"     // 완전한 헤더
✅ "S04D1T1C0I0W64_a16"       // P0 생략 (자동으로 P0)
✅ "S02D2T1C0I0W128P0_패턴"   // 이중 데이터라인
```

#### 잘못된 헤더 예시

```javascript
❌ "S04D1T1C0I0_a16"          // W 파라미터 누락
❌ "S04D1T1C0I0W64P0a16"      // 언더스코어(_) 누락
❌ "S00D1T1C0I0W64P0_a16"     // 스캔 비율 0 불가
❌ "S04D3T1C0I0W64P0_a16"     // 데이터 라인 3 불가 (1,2만 허용)
❌ "S04D2T5C0I0W32P0_a16"     // T 파라미터 5 불가 (0–4만 허용)
❌ "S08D2T4C0I0W16P0_a16"     // T4는 현재 1/4duty에 적용 (1/8 duty 사용 시 호환성 확인 필요)
❌ "S04D2T3C0I0W32P0_a16"     // T3은 현재 1/8duty에 적용 (1/4 duty 사용 시 호환성 확인 필요)
```

---

## 패턴 문자열 기본 요소

### 1. 행 문자 (a~q)

```
a=0행, b=1행, c=2행, …, q=16행
```

- **소문자만 사용** (대문자 사용 불가)
    
- LED 모듈의 행(Row) 번호를 나타냄
    

### 2. 숫자 (픽셀 수)

```
a16 → a행에서 16픽셀
b8  → b행에서 8픽셀
c32 → c행에서 32픽셀
```

- 해당 행에서 처리할 픽셀 수를 의미
    

### 3. 언더스코어(`_`) – 두 가지 용도

#### A. 역방향 표시 (행 문자 바로 뒤)

```
a_16 → a행에서 역방향(←)으로 16픽셀
b_8  → b행에서 역방향(←)으로 8픽셀
```

#### B. 그룹 구분자 (독립된 위치)

```
a16X2_b16X2 → 첫 번째 그룹: a16X2, 두 번째 그룹: b16X2
```

### 4. 반복 표시 (X숫자)

```
a16X2 → a16 패턴을 2번 반복
b8X4  → b8 패턴을 4번 반복
```

---

## 패턴 작성 방법

### 1단계: 기본 세그먼트 작성

가장 간단한 패턴부터 시작합니다:

```
a16    # a행에서 정방향으로 16픽셀
b_8    # b행에서 역방향으로 8픽셀
c32    # c행에서 정방향으로 32픽셀
```

### 2단계: 행 쌍 패턴 작성

두 행을 연속으로 배치:

```
ab16   # a행과 b행이 1픽셀씩 교대로 16픽셀
ef8    # e행과 f행이 1픽셀씩 교대로 8픽셀
gh32   # g행과 h행이 1픽셀씩 교대로 32픽셀
```

### 3단계: 반복 패턴 추가

같은 패턴을 여러 번 반복:

```
a16X2   # a16 패턴을 2번 반복 (총 32픽셀)
ab8X4   # ab8 패턴을 4번 반복 (총 32픽셀)
c_16X3  # c_16 패턴을 3번 반복 (총 48픽셀)
```

### 4단계: 복합 패턴 작성

여러 세그먼트를 조합:

```
a8b8c8d8      # 4개 행이 각각 8픽셀씩
a4c4e4g4X4    # 4개 행이 4픽셀씩, 4번 반복
ef8gh8X2      # 행 쌍 패턴 2번 반복
```

### 5단계: 그룹 분리 패턴

언더스코어로 독립된 그룹 분리:

```
a16X2_b16X2          # 두 개의 독립된 그룹
ef8gh8X2_ab8cd8X2    # 행 쌍 그룹 두 개
e_8g8X4_a_8c8X4      # 역방향이 포함된 그룹 두 개
```

---

## 패턴 예시

### 기본 패턴

```javascript
// 단일 행 패턴
"a16";    // a행 정방향 16픽셀
"b_8";    // b행 역방향 8픽셀

// 행 쌍 패턴
"ab16";   // a,b행 교대 16픽셀
"ef8";    // e,f행 교대 8픽셀

// 반복 패턴
"a16X2";  // a행 16픽셀을 2번 반복
"ab8X4";  // a,b행 교대 8픽셀을 4번 반복
```

### 중급 패턴

```javascript
// 복합 세그먼트
"a8b8c8d8";      // 4개 행이 각각 8픽셀
"a4c4e4g4X4";    // 4개 행이 4픽셀씩, 4번 반복

// 역방향 조합
"a_8b8c_8d8";    // 역방향과 정방향 혼합
"e_8g8X4";       // 역방향 포함 반복 패턴
```

### 고급 패턴 (그룹 분리)

```javascript
// 두 그룹으로 분리
"a16X2_b16X2";                 // 각각 독립된 반복 그룹
"ef8gh8X2_ab8cd8X2";           // 행 쌍 그룹 분리
"e_8g8X4_a_8c8X4";             // 역방향 그룹 분리

// 복합 그룹 분리
"a4c4e4g4X2_b4d4f4h4X2";       // 복합 세그먼트 그룹 분리
```

---

## 작성 규칙과 제한사항

### 크기 제한 (v3.0 메모리 최적화)

|요소|최대 크기|설명|예시|
|---|---|---|---|
|**전체 패턴**|30바이트|패턴 문자열 전체 길이|`"ef8gh8X2_ab8cd8X2"`|
|**행 문자 조합**|2바이트|세그먼트당 행 문자 수|`"ef"`, `"ab"`, `"gh"`|
|**그룹 수**|최대 2개|언더스코어로 분리된 그룹|`그룹1_그룹2`|
|**세그먼트 수**|최대 6개/그룹|각 그룹 내 세그먼트 수|`a4b4c4d4e4f4`|

### 허용되는 패턴

```javascript
// 기본 패턴
"a16";            // 단일 세그먼트
"ab16";           // 행 쌍
"a16X2";          // 반복 패턴
"a_16";           // 역방향

// 복합 패턴
"a4c4e4g4X4";     // 4개 세그먼트 반복
"ef8gh8X2";       // 행 쌍 반복
"e_8g8X2_a_8c8X2"; // 그룹 분리

// 혼합 패턴
"a8b_8c8d_8";     // 정방향/역방향 혼합
```

### 금지되는 패턴

```javascript
// 문자 사용 오류
"A16";            // 대문자 사용 불가
"ABC16";          // 대문자 조합 불가

// 크기 제한 위반
"abc16";          // 행 문자 3개 (2개 초과)
"a4b4c4d4e4f4g4X4"; // 세그먼트 7개 (6개 초과)
"a16X2_b16X2_c16X2"; // 그룹 3개 (2개 초과)

// 구조 오류
"a16_b16";         // 잘못된 언더스코어 사용
"aX2";             // 픽셀 수 없이 반복
"a16X";            // 반복 횟수 없이 X
```

---

## 패턴 동작 원리

1. **정방향 처리**
    
    ```
    a16 → X좌표: 0,1,2,3,…,15 (우측으로)
    ```
    
2. **역방향 처리**
    
    ```
    a_16 → X좌표: 15,14,13,12,…,0 (좌측으로)
    ```
    
3. **행 쌍 교대 처리**
    
    ```
    ab16 → a행: 0,1,2,3,…,15
           b행: 0,1,2,3,…,15 (동시에)
    ```
    
4. **반복 처리**
    
    ```
    a16X2 → 첫 번째: X좌표 0~15
             두 번째: X좌표 16~31
    ```
    
5. **그룹 분리 처리**
    
    ```
    a16_b16 → 그룹1: a16 (X좌표 0~15)
               그룹2: b16 (X좌표 0~15, 독립적)
    ```
    

---

## 자주 발생하는 오류

### 1. 대문자 사용 오류

```javascript
❌ "A16"    → ✅ "a16"
❌ "AB16"   → ✅ "ab16"
❌ "EF8X2"  → ✅ "ef8X2"
```

### 2. 언더스코어 위치 오류

```javascript
❌ "a16_b16"    → ✅ "a16X1_b16X1" (그룹 분리 시)
❌ "a_16_b8"    → ✅ "a_16b8" (단일 그룹) 또는 "a_16_b8X1" (그룹 분리)
```

### 3. 크기 초과 오류

```javascript
❌ "abc16"            → ✅ "ab16" (행 문자 2개까지)
❌ "a1b2c3d4e5f6g7X2" → ✅ "a1b2c3d4e5f6X2" (세그먼트 6개까지)
```

### 4. 반복 표기 오류

```javascript
❌ "aX2"       → ✅ "a8X2" (픽셀 수 필수)
❌ "a16X"      → ✅ "a16X2" (반복 횟수 필수)
❌ "Xa16"      → ✅ "a16X2" (X는 뒤에)
```

---

## 패턴 검증 방법

1. **구문 검사**
    
    - 소문자 행 문자 사용 확인 (a~q)
        
    - 숫자 형식 확인 (1~999)
        
    - 특수문자 사용 확인 (_ , X만 허용)
        
2. **크기 검사**
    
    - 전체 길이 30바이트 이하
        
    - 행 문자 조합 2바이트 이하
        
    - 그룹 수 2개 이하
        
    - 세그먼트 수 6개/그룹 이하
        
3. **논리 검사**
    
    - 언더스코어 위치 적절성
        
    - X 표기법 정확성
        
    - 픽셀 수 범위 (1~999)
        
    - 반복 횟수 범위 (1~99)
        

---

## 패턴 최적화 팁

### 1. 메모리 효율성

```javascript
// 권장: 간결한 표현
"ab16X2"; // 32픽셀을 효율적으로 표현

// 비권장: 복잡한 표현
"a16b16"; // 같은 결과이지만 비효율적
```

### 2. 가독성 향상

```javascript
// 권장: 명확한 구조
"ef8gh8X2_ab8cd8X2"; // 그룹 분리 명확

// 비권장: 모호한 구조
"ef8gh8ab8cd8X2"; // 그룹 구분 불명확
```

### 3. 확장성 고려

```javascript
// 권장: 반복 패턴 활용
"a4c4e4g4X8"; // 확장하기 쉬운 구조

// 비권장: 하드코딩
"a4c4e4g4a4c4e4g4a4c4e4g4..."; // 유지보수 어려움
```

---

## 실제 적용 사례

### 1/32 Duty 모듈

```javascript
// P1 비표준 2단 모듈 (스캔 방식이 다른 특수 모듈)
"S32D1T1C0I0W16P1_a16";
```

### 1/16 Duty 모듈

```javascript
// 표준 2단 6열 모듈 (단일 데이터라인)
"S16D1T1C0I0W16P0_a16";

// 표준 1단 4열 모듈 (이중 데이터라인)
"S16D2T1C0I0W16P0_a16";
```

### 1/8 Duty 모듈

```javascript
// 74HC595(SUM2017TD) 디코더 IC 적용 모듈
"S08D2T1C3I0W16P1_a16";

// 대형 모듈 (단일 데이터라인, W128)
"S08D1T1C0I0W128P0_i64a64";

// T4 디코더 IC 적용 모듈
"S08D1T1C4I0W32P0_i16a16";
```

**주요 특징:**

- **T3 (74HC595)**: SUM2017TD IC, 1/8 duty에서 주로 사용
    
- **T4**: L800 등 특수 디코더 IC
    
- **W128**: 대형 모듈의 경우 단일 라인으로 128픽셀 제어
    
- **복합 패턴**: `i64a64`처럼 서로 다른 행을 조합한 패턴
    

### 1/4 Duty 모듈

```javascript
// P1 비표준 모듈 (역방향 패턴 포함)
"S04D2T1C0I0W32P1_a_8e8X2";

// 표준 모듈 (P0 생략 가능)
"S04D2T1C0I0W32_ea16";

// 64픽셀 제어 모듈
"S04D2T1C0I0W64_ea32";
```

**패턴 특징:**

- **`a_8e8X2`**: a행 역방향 8픽셀 + e행 정방향 8픽셀을 2번 반복
    
- **`ea16`**: e행과 a행이 16픽셀씩 교대
    
- **P 파라미터 생략**: 표준 모듈은 P0 생략 가능
    

### 1/2 Duty 모듈

```javascript
// 디코더 IC 없는 모듈 (T0)
"S02D2T0C0I0W64P0_ac_4eg4X4";
```

**패턴 분석:**

- **`ac_4eg4X4`**: a행 + c행 4픽셀, 그룹 분리 후 e행 + g행 4픽셀을 4번 반복
    
- **T0**: 디코더 IC가 없는 1/4 duty와 1/2 duty 모듈에서 사용
    

---

### 디코더 IC별 적용 사례

|IC 타입|적용 Duty|실제 사례|비고|
|---|---|---|---|
|**T0**|1/4D, 1/2D|`S02D2T0C0I0W64P0_...`|디코더 IC 없음|
|**T1**|범용|`S16D1T1C0I0W16P0_...`|74HC138 정방향 (표준)|
|**T3**|1/8D|`S08D2T1C3I0W16P1_...`|74HC595(SUM2017TD)|
|**T4**|1/4D|`S08D1T1C4I0W32P0_...`|L800 등 특수 디코더|

### 모듈 타입별 분류

#### 표준 HUB75 모듈 (P0)

```javascript
"S16D1T1C0I0W16P0_a16";     // 2단 6열
"S16D2T1C0I0W16P0_a16";     // 1단 4열
"S04D2T1C0I0W32_ea16";      // 1/4 duty 표준
"S02D2T0C0I0W64P0_ac_4eg4X4"; // 1/2 duty 디코더 없음
```

#### 비표준 모듈 (P1)

```javascript
"S32D1T1C0I0W16P1_a16";     // 1/32 duty 특수 스캔
"S08D2T1C3I0W16P1_a16";     // 74HC595 디코더
"S04D2T1C0I0W32P1_a_8e8X2"; // 1/4 duty 특수 패턴
```

#### 대형/특수 사양 모듈

```javascript
"S08D1T1C0I0W128P0_i64a64"; // 128픽셀 단일 라인 제어
"S08D1T1C4I0W32P0_i16a16"; // T4 디코더 적용
"S04D2T1C0I0W64_ea32";     // 64픽셀 이중 라인
```

### 패턴 복잡도별 분류

#### 기본 패턴

```javascript
"a16"; // 단일 행 정방향
"ea16"; // 행 쌍 교대
```

#### 역방향 패턴

```javascript
"a_8e8X2"; // 역방향 포함 반복
```

#### 복합 패턴

```javascript
"i64a64";      // 서로 다른 행 조합
"ac_4eg4X4";   // 그룹 분리 + 반복
```

---

## 결론

HUB75 표출신호 패턴 문자열은 LED 모듈의 핵심 제어 요소입니다. 이 가이드의 규칙을 따라 작성하면 안정적이고 효율적인 LED 제어가 가능합니다.

**핵심 포인트:**

1. 소문자 행 문자 사용 (a~q)
    
2. 크기 제한 준수 (30바이트, 2개 그룹, 6개 세그먼트)
    
3. 언더스코어 위치 정확성
    
4. 반복 표기법 정확성
    
5. 패턴 검증 필수
    
6. **실제 적용 사례 참조**: 검증된 패턴들을 기반으로 응용
    

추가 질문이나 복잡한 패턴 작성이 필요한 경우, 기술 문서 `HUB75_LED모듈_표출신호_매핑프로토콜_v3.0.md`를 참조하시기 바랍니다.