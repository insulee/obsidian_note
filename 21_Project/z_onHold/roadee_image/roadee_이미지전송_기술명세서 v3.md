## 목차

1. 개요
2. 주요 장치 구성  
   2.1 서버  
   2.2 DB300eM  
   2.3 DB502S
3. 공통 통신 규격 & 패킷 규칙  
   3.1 MQTT & JSON  
   3.2 RS‑232 프레임  
   3.3 데이터 패킷 규칙(표준)
4. 서버 펌웨어 가이드  
   4.1 기술 스택  
   4.2 이미지 송신 로직  
   4.3 오류 처리 & 재전송
5. DB300eM 펌웨어 가이드  
   5.1 ImageTransfer 절차  
   5.2 Schedule 절차  
   5.3 메모리 관리 전략
6. DB502S 수신·저장 로직
7. 이미지 전송 테스트 시나리오  
   7.1 테스트 조건  
   7.2 청크별 전송량  
   7.3 전송 절차
8. “마지막 청크” 확인 절차
9. 스케줄 전송 처리 절차
10. 커밋 시점 결정 방식
11. 이미지 & 스케줄 전송 시퀀스
12. DB502S 적용 로직 요약
13. BMP → .dat 파일 표시 과정
   13.1 PC 환경 (다빛채)
   13.2 MQTT 통신 환경
   13.3 지원 형식 & 편집 툴
14. 전체 플로우 한눈 요약
15. 펌웨어 작업에 필요한 내용 추가

---

## 1. 개요

이 문서는 **서버 → DB300eM → DB502S** 전광판 시스템의 펌웨어·통신 흐름을 정의합니다. 느슨한 연결 환경을 견디기 위해 UDP/TCP 대신 **MQTT + RS‑232**를 조합했습니다.
- **이미지 전송**: BMP → Base64 → 청크 전송 → LittleFS 저장  
    (커밋 시) **LittleFS read → RS‑232(**`**0x92**`**) → DB502S**
- **스케줄 전송**: JSON → LittleFS 저장 → 자동/수동 커밋  
    (커밋 시) **RS‑232(**`**0x92**`**) → RS‑232(**`**0x91**`**) → DB502S**

---

## 2. 주요 장치 구성

### 2.1 서버

| 항목            | 사양 / 설정                                                                                                                        |
| --------------- | ---------------------------------------------------------------------------------------------------------------------------------- |
| 플랫폼          | Linux 또는 Windows 서버 (x64)                                                                                                      |
| 네트워크        | Gigabit Ethernet + MQTT 브로커                                                                                                     |
| MQTT 토픽       | Publish: `igw/tsc/dev`<br>Subscribe: `feedback.20`                                                                                 |
| QoS / Keepalive | QoS 0, Keepalive 60 s                                                                                                              |
| 재연결 정책     | 5 s 간격으로 5회 시도 후 지수 백오프(×2)                                                                                           |
| 역할            | - 이미지 파일 Base64 인코딩 & 청크화<br>- 스케줄 JSON 생성/관리<br>- 커밋(`deploy`) 명령 발행<br>- 장치 응답 수집 및 대시보드 표시 |

### 2.2 DB300eM (MQTT ↔ RS‑232 컨버터)

| 항목            | 사양 / 설정                                                                                                                      |
| --------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| MCU             | ESP32‑WROOM‑32E (dual‑core, 4 MB flash)                                                                                          |
| FW SDK          | ESP‑IDF v5.3.2                                                                                                                   |
| 파일 시스템     | LittleFS (wear‑levelling on)                                                                                                     |
| MQTT 클라이언트 | esp‑mqtt (QoS 0)                                                                                                                 |
| JSON 파서       | cJSON                                                                                                                            |
| Queue           | FreeRTOS Queue (depth = 10) – MQTT → worker task                                                                                 |
| UART            | 115200 bps, 8‑N‑1, no flow, TxTimeout 100 ms, RxTimeout 200 ms                                                                   |
| 주요 모듈       | - ImageTransfer (파일 수신·저장)<br>- Schedule (JSON 저장)<br>- ascii_proto/hex_proto (변환·전송)<br>- feedback (응답 MQTT 발행) |

### 2.3 DB502S (전광판 컨트롤러)

| 항목        | 사양 / 설정                                                                     |
| ----------- | ------------------------------------------------------------------------------- |
| MCU         | ESP32‑S3 (16 MB flash)                                                          |
| FW SDK      | ESP‑IDF v5.3.2                                                                  |
| 통신        | RS‑232 115200 bps (DB300eM 직결)                                                |
| 플래시 구조 | `flash_storage/`<br>- `list.bin` (목록 메타)<br>- `img/<N>.bin` (텍스트‑이미지) |
| 동작        | 0x92 → 이미지 이어쓰기, 0x91 → 목록 갱신 → 화면 리프레시                        |
| 오류 정책   | 체크섬·타임아웃 오류 시 오류 코드 회신(재전송 없음)                             |

---

## 3. 공통 통신 규격 & 패킷 규칙

### 3.1 MQTT & JSON

```jsonc
{
  "MSG_TYPE": "SET" | "RESP_SET",
  "MSG_ID": 1587432912731,
  "MOID": [ { "2.RTE058.4.1": "data" }, … ],
  "RESULT_CODE": 0,
  "RESULT_MSG": null,
  "RESULT": null
}
```

-   토픽: `igw/tsc/dev` (명령) / `feedback.20` (응답)
-   환경 변수 예시: `MQTT_BROKER`, `CHUNK_SIZE`, `RETRY_LIMIT`, `TIMEOUT_MS`

### 3.2 RS‑232 프레임

| 프로토콜 | 구조                     | 예시                     |
| -------- | ------------------------ | ------------------------ |
| HEX      | `DLE STX CMD DATA … ETX` | `10 02 94 01 FF … 10 03` |
| ASCII    | `![ PAYLOAD !] BCC(2B)`  | `![A0D9901!]5A7E`        |

### 3.3 데이터 패킷 규칙 (표준)

| 단계  | `2.RTE058.4.1` | 포함 내용                         | `chunk_index`        | 설명                   |
| ----- | -------------- | --------------------------------- | -------------------- | ---------------------- |
| start | "start"        | 메타(`file_size`, `total_chunks`) | 0                    | **Base64 데이터 없음** |
| data  | "data"         | Base64 바이너리                   | 1 ~ `total_chunks–1` | 실제 데이터            |
| end   | "end"          | 남은 데이터 또는 빈 페이로드      | `total_chunks`       | 전송 완료              |

> `total_chunks = 1`이면 `start`→`end` 두 패킷만 전송 (`data` 없음)

---

## 4. 서버 펌웨어 가이드

### 4.1 기술 스택

-   인코딩: 표준 Base64 (RFC 4648)

### 4.2 이미지 송신 로직

1. BMP(8 bpp, 32 × 32) 읽기 → Base64 인코딩 → `chunk_size`(1024 B) 단위 분할
2. `start`(`chunk_index`:0, 메타만) Publish
3. 첫 `data`(`chunk_index`:1) Publish
4. 중간 `data` 패킷 연속 Publish
5. `end`(`chunk_index`:total_chunks) Publish; 페이로드 길이 0 또는 잔여 데이터

### 4.3 오류 처리 & 재전송

| 유형       | 트리거                     | 조치                           |
| ---------- | -------------------------- | ------------------------------ |
| NACK       | DB300eM이 누락 인덱스 통보 | 해당 인덱스만 재Publish        |
| 타임아웃   | `feedback` 미수신 5 s      | 동일 패킷 재Publish (최대 3회) |
| MD5 불일치 | `end` 후 해시 비교 실패    | 전체 파일 재송신               |

---

## 5. DB300eM 펌웨어 가이드

### 5.1 ImageTransfer 절차

- 저장 경로: `/littlefs/images/<filename>.json`
   - `<filename>` 은 MOID 필드 "2.RTE058.4.2.1" 값 (예: "flashing.bmp")
- 파일명 예시: `/littlefs/images/flashing.bmp.json`
1. start 수신 → /littlefs/images/<filename>.json 파일을 wb 모드로 오픈
2. data 수신 → Base64 디코드 → fwrite → chunk_index 일치 여부 검증
3. end 수신 → fclose → 전체 파일 크기 검증 → 결과에 따라 OK 또는 NACK 반환

- **무결성 검증은 MD5 우선(수신 시 필수 비교) → 그다음 파일 크기 확인 순으로 수행하며, MD5가 없는 예외 상황에는 크기 검증만으로 전송 완료를 판단한다.**

### 5.2 Schedule 절차

-   `set` → `/littlefs/schedules/<ID>.json` 저장
-   `list` → 디렉터리 스캔 후 JSON 배열 응답
-   `clear` → 스케줄·이미지 파일 일괄 삭제

### 5.3 메모리 관리 전략 (파편화 대응)

| 대책                 | 핵심 아이디어                           | ESP‑IDF 구현 포인트                                 |
| -------------------- | --------------------------------------- | --------------------------------------------------- |
| 정적·영구 버퍼 우선  | BSS/static 영역에 버퍼 확보, 재사용     | `static uint8_t img_buf[8*1024];`                   |
| 단일 풀(pool) 할당   | `heap_caps_malloc()` 1회로 큰 블록 확보 | `void *pool = heap_caps_malloc(32*1024,…);`         |
| 지역(스택) 버퍼 활용 | 1 KB 이하 임시 데이터는 스택 사용       | Task 스택 = 기본 + 2 KB 여유                        |
| 힙 구역(cap) 분리    | DMA용 vs 일반용 cap 분리                | `MALLOC_CAP_DMA`, `MALLOC_CAP_8BIT`                 |
| 가변 재할당 금지     | `realloc()` 금지, 버퍼 재사용           | cJSON 파싱 노드 캐시 재활용                         |
| TLSF 할당기 사용     | `CONFIG_HEAP_TLSF=y`                    | 메뉴config → Heap memory debugging                  |
| Heap trace & stress  | 누수·조각 추적                          | `heap_trace_start()`, `heap_caps_print_heap_info()` |
| 데이터 전달 최적화   | 큐/링버퍼로 포인터 전달, 복사 최소화    | `xRingbufferSend()` / `Receive()`                   |

```c
#define CHUNK_MAX_B64 1368  // 1024B 바이너리 → Base64 크기
static uint8_t *b64_pool;

void img_module_init(void)
{
    b64_pool = heap_caps_malloc(CHUNK_MAX_B64, MALLOC_CAP_8BIT);
    assert(b64_pool);
}

void img_on_data(const char *b64, size_t len)
{
    memcpy(b64_pool, b64, len);
    size_t bin_len = base64_decode(b64_pool, len, bin_buf, sizeof(bin_buf));
    fwrite(bin_buf, 1, bin_len, fp);
}

void img_module_deinit(void)
{
    free(b64_pool);
}
```

---

## 6. DB502S 수신·저장 로직

| OPCODE | 동작                 | 플래시 경로                 | ACK        |
| ------ | -------------------- | --------------------------- | ---------- |
| 0x92   | 이미지 블록 이어쓰기 | `flash_storage/img/<N>.bin` | 1 B (0x00) |
| 0x91   | 목록 갱신            | `flash_storage/list.bin`    | 1 B (0x00) |

-   0x92 → 0x91 수신 시 즉시 화면 리프레시
-   오류 응답: BCC mismatch→0xF1, 타임아웃→0xF2

---

## 7. 이미지 전송 테스트 시나리오

### 7.1 테스트 조건

-   BMP 8 bpp 32 × 32 픽셀 → 원본 2 048 B, Base64 2 736 B

### 7.2 청크별 전송량

| 단계                | 전송 데이터 크기           | 설명                           |
| ------------------- | -------------------------- | ------------------------------ |
| 시작 청크 (start)   | 72 바이트                  | 파일 정보를 담은 JSON 메타데이터 |
| 데이터 청크 1번     | 1,368 바이트               | Base64로 인코딩된 첫 번째 데이터 블록 |
| 중간 데이터 청크... | 1,368 바이트               | 순차적으로 전송되는 데이터 블록들 |
| 종료 청크 (end)     | 0 바이트 또는 남은 데이터  | 전송 완료 표시 또는 마지막 데이터 |

### 7.3 전송 절차

1. GUI → 청크화 → MQTT Publish
2. DB300eM → 파일 저장 → `end` 수신 → MD5 검증
3. NACK 발생 시 서버는 해당 인덱스만 재Publish

---

## 8. “마지막 청크” 확인 절차

`MOID["2.RTE058.4.1"] == "end"` 패킷 도착을 **완료 조건**으로 정의합니다.  
(end 패킷에는 잔여 바이너리 또는 빈 페이로드)

---

## 9. 스케줄 전송 처리 절차

`2.RTE058.5.1` 필드로 `set`/`list`/`clear`/`deploy` 네 가지 명령을 처리합니다.

| 명령   | JSON 예시                     | 동작                                 | 서버 응답       |
| ------ | ----------------------------- | ------------------------------------ | --------------- |
| set    | `{ "2.RTE058.5.1":"set",… }`  | `/littlefs/schedules/<ID>.json` 저장 | `RESULT_CODE:0` |
| list   | `{ "2.RTE058.5.1":"list" }`   | 디렉터리 스캔 후 배열 반환           | 배열 JSON       |
| clear  | `{ "2.RTE058.5.1":"clear" }`  | 스케줄·이미지 파일 일괄 삭제         | `RESULT_CODE:0` |
| deploy | `{ "2.RTE058.5.1":"deploy" }` | 즉시 커밋 트리거 (0x92→0x91 전송)    | `RESULT_CODE:0` |

-   `deploy` 명령 수신 시 **자동 커밋 타이머 초기화** (항상 우선)

---

## 10. 커밋 시점 결정 방식

| 모드      | 트리거                               | DB300eM 동작                      | 사용 예                    |
| --------- | ------------------------------------ | --------------------------------- | -------------------------- |
| 수동 커밋 | `{ "2.RTE058.5.1":"deploy" }`        | 즉시 0x92(이미지)→0x91(목록) 전송 | 운영자 검수 후 배포        |
| 자동 커밋 | 이미지·스케줄 최신 & 5 s 타이머 만료 | 자동 0x92→0x91 전송               | 실시간 게시판, 지연 최소화 |

---

## 11. 이미지 & 스케줄 전송 시퀀스

1. **Display Stop 전송**
    ```
    10 02 00 00 00 45 00 10 03
    // DLE STX DST LEN CMD DATA DLE ETX
    // CMD=0x45, DATA=0x00 (Display Off)
    ```
2. **0x91 목록(스케줄) 전송**
    - 이미지 파일 정렬 순서: 스케줄 파일명을 오름차순으로 정렬합니다. (예: `{ "2.RTE058.5.2.1": "12345" }`)  
    - DB502S에서는 이 순서를 화면 표출 순서로 사용합니다.
3. **0x92 이미지 전송**
    - “첫 번째 청크(LEN=0x0450, 1104 B): 파일 헤더(32 B) + 원본 1 024 B 블록”
    - “이후 청크(LEN=0x040A, 1034 B): 원본 1 024 B 블록만”  
4. **Display Start 전송**
    ```
    10 02 00 00 01 45 01 10 03
    // CMD=0x45, DATA=0x01 (Display On)
    ```
5. **완료 보고**
    - 전송 성공 후 `{"RESULT_CODE":0}` MQTT Publish
    - 전송 실패 시 오류 코드 회신

---

## 12. DB502S 적용 로직 요약

| 수신 | 저장 위치                   | 즉시 동작       |
| ---- | --------------------------- | --------------- |
| 0x92 | `flash_storage/img/<N>.bin` | 이미지 이어쓰기 |
| 0x91 | `flash_storage/list.bin`    | 목록 갱신       |
| 완료 | —                           | 화면 리프레시   |

-   재부팅 시에도 `list.bin` + `img/` 로 이전 현수막 유지

---

## 13. BMP → .dat 파일 표시 과정

### 13.1 PC 환경 (다빛채)

1. 다빛채 편집기에서 BMP 파일에 텍스트 입력 후 `.dat` 파일로 변환
2. 변환된 `.dat` 파일을 Serial(USB‑RS232)로 db502S에 전송
3. db502S가 `.dat` 파일을 프레임 단위로 읽어 화면 구성
    
### 13.2 MQTT 통신 환경

1. 서버가 BMP 파일을 MQTT(`igw/tsc/dev`)로 전송 → DB300eM 수신
2. DB300eM이 BMP를 텍스트 이미지 `.dat`로 변환 후 RS‑232(`0x92`)로 DB502S 전달
3. DB502S가 `.dat` 파일을 동일 방법으로 프레임 단위 처리 후 화면 구성

### 13.3 지원 형식 & 편집 툴

|   |   |
|---|---|
|항목|값|
|파일 형식|8‑bit Bitmap(BMP)|
|편집 툴|다빛채 전용 편집기, mtPaint 호환|

---

## 14. 전체 플로우 한눈 요약

```
[서버]
  ├─ start(메타) ─►
  ├─ data × N ───►    RS‑232 0x91 목록 ─► DB502S (ACK)
  ├─ end(완료) ──►
             RS‑232 0x92 이미지 ─► DB502S (ACK)
                        ▲
 커밋 트리거 ───────────┘ (자동/수동)
```

-   start : 메타 전용, 데이터 없음
-   data : 바이너리 포함, `chunk_index` 1부터
-   end : 마지막 바이너리 또는 빈 페이로드


## 15. 펌웨어 작업에 필요한 내용 추가
    - 전광판 화면 크기는 최대 **96×32** 픽셀로 제한한다.
        - **텍스트 이미지 파일 크기 산정 방법**
            1. **파일 헤더**: 32 B
            2. **편집 메타데이터**: 256 B (모두 0으로 채움)
            3. **이미지 프레임 데이터**: 모듈 수 × 256 B
                - 모듈당 **16×16** 픽셀 → 256 B
                - 예시: **96×32** (2단×6열) → 12모듈 → 12 × 256 B = 3,072 B
            4. **총 파일 크기** = 파일 헤더 + 편집 메타데이터 + 이미지 프레임 데이터

    - 스케줄 파일은 최대 **10개**까지 허용한다.
        - 파일 이름은 최대 **10자**(영문자, 숫자, 밑줄(`_`)만 사용)이다.
        - 파일 이름은 중복될 수 없으며, 오름차순으로 정렬된 순서대로 화면에 표시된다.

