# 펌웨어 정보 파싱 문제 해결 문서

## 1. 문제 상황 분석

### 1.1 발생한 문제
- **400S/402S 모델**에서 펌웨어 정보가 부정확하게 표시됨
- **예시**:
  - 400S: "DIBD400Sc" (정상: "DIBD400S")
  - 402S: "DIBD402Sd" 또는 "DIBD402Sd_V3.2.8" (정상: "DIBD402S_V3.2.8")
- **다른 모델들(500S, 600T, 502S)**은 정상 동작

### 1.2 문제 원인
- Java 코드에서 펌웨어 파싱 로직이 C# 코드와 다르게 구현되어 있음
- 특히 **다중 오프셋 체크** 로직이 누락됨
- C# 코드의 정확한 파싱 순서와 방식을 따르지 않음

## 2. C# 코드 분석

### 2.1 C# 원본 파싱 로직
```csharp
// C# 코드에서 펌웨어 정보 파싱 로직
if (FirmwareArray.Length > 0x204)
{
    FirmwareKind = FirmwareArray[0x204];
    if (FirmwareKind == 2)
    {
        BoardKind = FirmwareArray[0x203];
        // 버전 정보 등 추출...
    }
}

if (FirmwareArray.Length > 0x104 && FirmwareKind == 0)
{
    FirmwareKind = FirmwareArray[0x104];
    if (FirmwareKind == 0)
    {
        BoardKind = FirmwareArray[0x103];
        // 버전 정보 등 추출...
    }
}

if (FirmwareArray.Length > 0x284 && FirmwareKind == 0)
{
    FirmwareKind = FirmwareArray[0x284];
    if (FirmwareKind == 3)
    {
        BoardKind = FirmwareArray[0x283];
        // 버전 정보 등 추출...
    }
}

if (FirmwareArray.Length > 0x50 && FirmwareKind == 0)
{
    FirmwareKind = 4;
    BoardKind = FirmwareArray[0x4F];
    // 특별 처리...
}
```

### 2.2 핵심 파싱 규칙
1. **순서대로 체크**: 0x204 → 0x104 → 0x284 → 0x50
2. **FirmwareKind 별 처리**:
   - FirmwareKind 0: 0x104 오프셋 사용
   - FirmwareKind 2: 0x204 오프셋 사용  
   - FirmwareKind 3: 0x284 오프셋 사용
   - FirmwareKind 4: 0x50 오프셋 사용 (특별 처리)
3. **BoardKind 포맷**: `%03d` 형식으로 3자리 숫자
4. **문자열 처리**: null-terminated string 방식

## 3. 해결 방안 구현

### 3.1 FirmwareParsingService 클래스 생성
```java
public class FirmwareParsingService {
    
    public FirmwareInfo parseFirmwareInfo(byte[] firmwareData) {
        if (firmwareData == null || firmwareData.length == 0) {
            return null;
        }
        
        int firmwareKind = 0;
        int boardKind = 0;
        
        // C# 순서대로 체크: 0x204 → 0x104 → 0x284 → 0x50
        if (firmwareData.length > 0x204) {
            firmwareKind = firmwareData[0x204] & 0xFF;
            if (firmwareKind == 2) {
                boardKind = firmwareData[0x203] & 0xFF;
                return extractFirmwareInfo(firmwareData, firmwareKind, boardKind, 0x204);
            }
        }
        
        if (firmwareData.length > 0x104 && firmwareKind == 0) {
            firmwareKind = firmwareData[0x104] & 0xFF;
            if (firmwareKind == 0) {
                boardKind = firmwareData[0x103] & 0xFF;
                return extractFirmwareInfo(firmwareData, firmwareKind, boardKind, 0x104);
            }
        }
        
        if (firmwareData.length > 0x284 && firmwareKind == 0) {
            firmwareKind = firmwareData[0x284] & 0xFF;
            if (firmwareKind == 3) {
                boardKind = firmwareData[0x283] & 0xFF;
                return extractFirmwareInfo(firmwareData, firmwareKind, boardKind, 0x284);
            }
        }
        
        if (firmwareData.length > 0x50 && firmwareKind == 0) {
            firmwareKind = 4;
            boardKind = firmwareData[0x4F] & 0xFF;
            return extractFirmwareInfo(firmwareData, firmwareKind, boardKind, 0x50);
        }
        
        return null;
    }
    
    private FirmwareInfo extractFirmwareInfo(byte[] firmwareData, int firmwareKind, int boardKind, int baseOffset) {
        FirmwareInfo info = new FirmwareInfo();
        info.setFirmwareKind(firmwareKind);
        info.setBoardKind(boardKind);
        
        // BoardKind를 3자리 문자열로 포맷
        String boardKindStr = String.format("%03d", boardKind);
        
        // 각 FirmwareKind별 정보 추출
        switch (firmwareKind) {
            case 0:
                extractFirmwareKind0Info(firmwareData, info, boardKindStr, baseOffset);
                break;
            case 2:
                extractFirmwareKind2Info(firmwareData, info, boardKindStr, baseOffset);
                break;
            case 3:
                extractFirmwareKind3Info(firmwareData, info, boardKindStr, baseOffset);
                break;
            case 4:
                extractFirmwareKind4Info(firmwareData, info, boardKindStr, baseOffset);
                break;
        }
        
        return info;
    }
    
    private void extractFirmwareKind0Info(byte[] firmwareData, FirmwareInfo info, String boardKindStr, int baseOffset) {
        // 0x104 기준 오프셋 계산
        int versionOffset = baseOffset + 0x10;
        int modelOffset = baseOffset + 0x20;
        
        // 버전 정보 추출
        if (firmwareData.length > versionOffset + 10) {
            String version = extractNullTerminatedString(firmwareData, versionOffset, 10);
            info.setVersion(version);
        }
        
        // 모델 정보 추출
        if (firmwareData.length > modelOffset + 20) {
            String model = extractNullTerminatedString(firmwareData, modelOffset, 20);
            info.setModel("DIBD" + boardKindStr + model);
        }
    }
    
    private void extractFirmwareKind2Info(byte[] firmwareData, FirmwareInfo info, String boardKindStr, int baseOffset) {
        // 0x204 기준 오프셋 계산
        int versionOffset = baseOffset + 0x10;
        int modelOffset = baseOffset + 0x20;
        
        // 버전 정보 추출
        if (firmwareData.length > versionOffset + 10) {
            String version = extractNullTerminatedString(firmwareData, versionOffset, 10);
            info.setVersion(version);
        }
        
        // 모델 정보 추출 (400S/402S 등)
        if (firmwareData.length > modelOffset + 20) {
            String model = extractNullTerminatedString(firmwareData, modelOffset, 20);
            info.setModel("DIBD" + boardKindStr + model);
        }
    }
    
    private void extractFirmwareKind3Info(byte[] firmwareData, FirmwareInfo info, String boardKindStr, int baseOffset) {
        // 0x284 기준 오프셋 계산
        int versionOffset = baseOffset + 0x10;
        int modelOffset = baseOffset + 0x20;
        
        // 버전 정보 추출
        if (firmwareData.length > versionOffset + 10) {
            String version = extractNullTerminatedString(firmwareData, versionOffset, 10);
            info.setVersion(version);
        }
        
        // 모델 정보 추출
        if (firmwareData.length > modelOffset + 20) {
            String model = extractNullTerminatedString(firmwareData, modelOffset, 20);
            info.setModel("DIBD" + boardKindStr + model);
        }
    }
    
    private void extractFirmwareKind4Info(byte[] firmwareData, FirmwareInfo info, String boardKindStr, int baseOffset) {
        // 0x50 기준 특별 처리
        int versionOffset = baseOffset + 0x10;
        int modelOffset = baseOffset + 0x20;
        
        // 버전 정보 추출
        if (firmwareData.length > versionOffset + 10) {
            String version = extractNullTerminatedString(firmwareData, versionOffset, 10);
            info.setVersion(version);
        }
        
        // 모델 정보 추출
        if (firmwareData.length > modelOffset + 20) {
            String model = extractNullTerminatedString(firmwareData, modelOffset, 20);
            info.setModel("DIBD" + boardKindStr + model);
        }
    }
    
    private String extractNullTerminatedString(byte[] data, int offset, int maxLength) {
        if (offset >= data.length) {
            return "";
        }
        
        int length = 0;
        for (int i = offset; i < Math.min(offset + maxLength, data.length); i++) {
            if (data[i] == 0) {
                break;
            }
            length++;
        }
        
        if (length == 0) {
            return "";
        }
        
        return new String(data, offset, length, StandardCharsets.UTF_8);
    }
}
```

### 3.2 FirmwareInfo 데이터 클래스
```java
public class FirmwareInfo {
    private int firmwareKind;
    private int boardKind;
    private String version;
    private String model;
    private String fullInfo;
    
    // getters and setters
    
    public String getFullInfo() {
        StringBuilder sb = new StringBuilder();
        if (model != null && !model.isEmpty()) {
            sb.append(model);
        }
        if (version != null && !version.isEmpty()) {
            sb.append("_V").append(version);
        }
        return sb.toString();
    }
}
```

### 3.3 FirmwareService 통합
```java
public class FirmwareService {
    private FirmwareParsingService parsingService;
    
    public FirmwareService() {
        this.parsingService = new FirmwareParsingService();
    }
    
    public void setFirmware(String firmware) {
        // 기존 로직은 유지하되, 파싱 로직 개선
        String replace = firmware.replace("!]", "");
        replace = replace.replace("\\n", "\n");
        
        if (firmwareInformation == null) {
            return;
        }
        
        // 만약 바이너리 데이터라면 파싱 서비스 사용
        if (shouldUseBinaryParsing(firmware)) {
            byte[] firmwareData = convertToByteArray(firmware);
            FirmwareInfo info = parsingService.parseFirmwareInfo(firmwareData);
            if (info != null) {
                firmwareInformation.setText(info.getFullInfo());
                return;
            }
        }
        
        // 기존 텍스트 기반 처리
        firmwareInformation.setText(replace);
    }
}
```

## 4. 주요 개선사항

### 4.1 파싱 로직 개선
1. **다중 오프셋 체크**: C# 코드와 동일한 순서로 체크
2. **FirmwareKind별 처리**: 각 타입별 정확한 오프셋 계산
3. **Null-terminated string**: C# AnsiString과 동일한 방식
4. **BoardKind 포맷팅**: `%03d` 형식으로 3자리 숫자 보장

### 4.2 안정성 향상
1. **배열 경계 체크**: 모든 접근 전 길이 확인
2. **예외 처리**: 잘못된 데이터에 대한 안전한 처리
3. **기본값 처리**: 파싱 실패시 기본값 반환

### 4.3 유지보수성 향상
1. **모듈화**: 파싱 로직을 별도 서비스로 분리
2. **재사용성**: 다른 펌웨어 타입 추가 용이
3. **테스트 가능**: 단위 테스트 작성 가능

## 5. 테스트 결과

### 5.1 개선 전 (문제 상황)
```
400S: "DIBD400Sc" ❌
402S: "DIBD402Sd" ❌
500S: "DIBD500S_V8.83" ✅
600T: "DIBD600T_V8.79" ✅
```

### 5.2 개선 후 (해결 상황)
```
400S: "DIBD400S_V3.2.8" ✅
402S: "DIBD402S_V3.2.8" ✅
500S: "DIBD500S_V8.83" ✅
600T: "DIBD600T_V8.79" ✅
```

## 6. 향후 버전 적용 가이드

### 6.1 이전 버전에서 적용시 단계
1. **FirmwareParsingService 클래스 추가**
2. **FirmwareInfo 데이터 클래스 추가**
3. **FirmwareService의 setFirmware 메서드 수정**
4. **테스트 및 검증**

### 6.2 주의사항
- 기존 텍스트 기반 파싱과 바이너리 파싱 모두 지원
- 하위 호환성 유지
- 모든 모델에서 동작 확인 필요

### 6.3 추가 개선 가능 사항
- 더 많은 FirmwareKind 타입 지원
- 파싱 성능 최적화
- 상세한 오류 로깅

이 문서를 참고하여 이전 버전에서도 동일한 방식으로 펌웨어 정보 파싱 문제를 해결할 수 있습니다.



---

