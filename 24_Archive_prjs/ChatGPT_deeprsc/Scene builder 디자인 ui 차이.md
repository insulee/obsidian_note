좋습니다. 이제 JavaFX Scene Builder에서 만든 UI와 실제 프로그램 실행 시 보이는 UI 사이에 발생하는 차이를 줄이기 위한 대안 도구 추천과 해결 방법에 대해 조사하겠습니다. 또한 Scene Builder 외에 실행 화면과 UI 일치도가 더 높은 도구가 있다면, 해당 도구의 사용법까지 함께 정리해드릴게요.

# Scene Builder 디자인과 실제 실행 UI 간 차이: 원인과 해결

JavaFX **Scene Builder**에서 설계한 인터페이스가 실제 애플리케이션 실행 시 다르게 보이는 문제는 종종 발생합니다. 예를 들어 Scene Builder 미리보기에서는 폰트 크기와 컴포넌트 배치가 일정하게 보였지만, 실제 실행 화면에서는 글자가 더 크게 표시되거나 버튼 위치가 어긋나는 식입니다. 이러한 불일치는 JavaFX/Java 버전, **고해상도 DPI 설정**, CSS 적용 방식, 레이아웃 설정 등 여러 요인에서 비롯됩니다. 아래에서는 대표적인 원인들과 구체적인 해결 방법을 정리합니다.

## 1. FXML/JavaFX 버전 및 JDK 버전 불일치

**원인:** Scene Builder가 생성한 FXML 파일이 사용하는 JavaFX 버전과 애플리케이션이 실행될 때 사용하는 JavaFX(JDK) 버전이 다르면 UI가 예상과 달리 나타날 수 있습니다. 예를 들어, Scene Builder가 JavaFX 9 환경에서 작성한 FXML (`xmlns="http://javafx.com/javafx/9.0.1"`)을 JavaFX 8로 실행하면 경고나 스타일 차이가 발생할 수 있습니다 ([java - JavaFX execution has a bigger frame than SceneBuilder preview - Stack Overflow](https://stackoverflow.com/questions/49418164/javafx-execution-has-a-bigger-frame-than-scenebuilder-preview/49418747#:~:text=%40jewelsea%20Scenebuilder%20was%20generating%20a,used%20to%20jres%20and%20libraries)). 실제 사례로 **JavaFX 9용 Scene Builder**로 작성된 FXML을 **JDK 8**로 실행한 경우, 윈도우 크기가 비정상하게 크게 나타나고 호환성 오류가 발생했습니다 ([java - JavaFX execution has a bigger frame than SceneBuilder preview - Stack Overflow](https://stackoverflow.com/questions/49418164/javafx-execution-has-a-bigger-frame-than-scenebuilder-preview/49418747#:~:text=0)). 이는 JavaFX 기본 테마(Modena)나 컴포넌트 동작이 버전별로 약간 다르기 때문입니다.

**해결:** 사용 중인 **JavaFX SDK와 JDK의 버전을 일치**시키는 것이 중요합니다. Scene Builder의 FXML 헤더에 명시된 JavaFX 버전을 확인하고, 애플리케이션이 해당 버전의 JavaFX 라이브러리를 사용하도록 설정해야 합니다. 예를 들어 Scene Builder 11로 작성한 FXML은 **OpenJFX 11** 라이브러리와 함께 실행하고, JDK 8 내장 JavaFX를 사용할 경우 **Scene Builder 8**을 사용하는 식입니다. 만약 버전을 맞추기 어렵다면, FXML 파일의 namespace 선언을 현재 사용 버전에 맞게 수정하는 방법도 있습니다. 그러나 가장 권장되는 방법은 **동일한 JavaFX 버전 환경에서 디자인 및 실행**하는 것입니다 ([java - JavaFX execution has a bigger frame than SceneBuilder preview - Stack Overflow](https://stackoverflow.com/questions/49418164/javafx-execution-has-a-bigger-frame-than-scenebuilder-preview/49418747#:~:text=0)). 버전 불일치로 인한 오류나 경고(예: _“Invalid resource: X not found…”_ 등)가 발생하면, 해당 리소스나 클래스가 해당 버전에 존재하는지 점검해야 합니다.

## 2. **고해상도 DPI 설정에 따른 UI 스케일 차이**

**원인:** **Windows**나 macOS에서 **고DPI(High DPI)** 디스플레이를 사용하면 JavaFX 애플리케이션이 자동으로 UI 스케일링을 적용하여, Scene Builder에서 본 것보다 크게(또는 작게) 표시될 수 있습니다. 예를 들어 **Windows 10**에서 디스플레이 배율을 150%로 설정한 경우, Scene Builder 미리보기에서는 창 크기를 1280×800으로 디자인했더라도 실제 실행하면 약 **1.5배 확대**되어 1920×1200 크기로 보일 수 있습니다 ([java - JavaFX scene scales differently in Scene builder and run time on Windows 10 - Stack Overflow](https://stackoverflow.com/questions/43195515/javafx-scene-scales-differently-in-scene-builder-and-run-time-on-windows-10#:~:text=I%20using%20Scene%20Builder%20with,setting%20the%20scene%20size%201280x800)). 아래 첫 번째 이미지는 Scene Builder의 미리보기이고, 두 번째 이미지는 실제 프로그램 실행 화면입니다. 동일한 FXML임에도 불구하고 실행 화면에서 글자와 레이아웃이 전반적으로 확대되어 일부 내용이 창에 다 나오지 않는 문제가 발생했습니다. 이는 JavaFX가 **디스플레이 DPI를 감지하여 UI 요소를 자동 확대**하기 때문입니다 ([java - JavaFX scene scales differently in Scene builder and run time on Windows 10 - Stack Overflow](https://stackoverflow.com/questions/43195515/javafx-scene-scales-differently-in-scene-builder-and-run-time-on-windows-10#:~:text=I%20using%20Scene%20Builder%20with,setting%20the%20scene%20size%201280x800)).

([Preview window and actual window different sizes : r/JavaFX](https://www.reddit.com/r/JavaFX/comments/a0ryer/preview_window_and_actual_window_different_sizes/)) **Scene Builder 미리보기** – Scene Builder에서 본 디자인 화면 (정상적인 레이아웃과 크기) ([java - JavaFX scene scales differently in Scene builder and run time on Windows 10 - Stack Overflow](https://stackoverflow.com/questions/43195515/javafx-scene-scales-differently-in-scene-builder-and-run-time-on-windows-10#:~:text=I%20using%20Scene%20Builder%20with,setting%20the%20scene%20size%201280x800)).

([Preview window and actual window different sizes : r/JavaFX](https://www.reddit.com/r/JavaFX/comments/a0ryer/preview_window_and_actual_window_different_sizes/)) **실행 시 화면** – Windows 고DPI 설정(예: 150%)으로 인해 UI 요소가 확대되어 글씨와 간격이 커진 실행 화면 ([java - JavaFX scene scales differently in Scene builder and run time on Windows 10 - Stack Overflow](https://stackoverflow.com/questions/43195515/javafx-scene-scales-differently-in-scene-builder-and-run-time-on-windows-10#:~:text=I%20using%20Scene%20Builder%20with,setting%20the%20scene%20size%201280x800)).

**해결:** **DPI 스케일링**으로 인한 차이를 줄이려면 두 가지 접근을 고려할 수 있습니다. 첫째, **JavaFX의 자동 DPI 스케일을 비활성화**합니다. 애플리케이션 시작 시 `System.setProperty("prism.allowhidpi", "false");`를 가장 먼저 호출하거나, JVM 옵션에 `-Dprism.allowhidpi=false`를 설정하여 JavaFX가 DPI에 관계없이 100% 배율로 렌더링하도록 할 수 있습니다 ([Java: Is it possible to disable Windows DPI scaling from within java? - Stack Overflow](https://stackoverflow.com/questions/30824996/java-is-it-possible-to-disable-windows-dpi-scaling-from-within-java#:~:text=4)). 이 설정은 Application.launch() 전에 적용되어야 효과가 있습니다. 둘째, **운영체제 측 설정**을 조정합니다. Windows의 경우 실행 파일의 속성 > 호환성 > 고 DPI 설정 변경에서 DPI 조정을 **애플리케이션이 아니라 시스템 또는 시스템(향상됨)**이 하도록 변경하면 ([java - Intellij IDEA JavaFX Scene Builder different resolution to the rest of the application - Stack Overflow](https://stackoverflow.com/questions/50003269/intellij-idea-javafx-scene-builder-different-resolution-to-the-rest-of-the-appli/50009067#:~:text=It%27s%20a%20known%20issue)), JavaFX 애플리케이션이 자체적으로 DPI 처리하지 않고 운영체제가 화면을 조정하여 Scene Builder에서 본 크기와 유사하게 표시될 수 있습니다. 다만 이 방식은 글꼴이 약간 블러리하게 보일 수 있는 단점이 있습니다.

추가로, **초기 Stage/Scene 크기 설정**을 Scene Builder의 **pref 크기와 일치**시키는 것도 중요합니다. Scene Builder에서 레이아웃한 루트 컨테이너의 prefWidth/prefHeight를 존중하려면, `new Scene(root)` 생성 시 크기를 지정하지 않거나 `stage.sizeToScene()`을 호출해주는 것이 좋습니다. 예를 들어, Scene Builder에서 AnchorPane의 prefWidth를 800으로 했는데 코드에서 `new Scene(root, 1200, 800)`처럼 다른 크기로 지정하면 레이아웃이 왜곡될 수 있습니다 ([java - Why does this JavaFX application look way different than when it's in SceneBuilder? - Stack Overflow](https://stackoverflow.com/questions/59586746/why-does-this-javafx-application-look-way-different-than-when-its-in-scenebuild#:~:text=Two%20reasons%3A%20,preferred%20dimensions%20of%20the%20root)). 따라서 고DPI 환경에서는 **(1)** JavaFX의 DPI 인식 기능을 끄거나, **(2)** OS DPI 설정을 변경하고, **(3)** Scene 크기 설정을 주의하여 디자인과 실행 화면의 비율 차이를 없앨 수 있습니다.

## 3. **CSS 스타일 적용 문제** (스타일 시트 불일치)

**원인:** Scene Builder에서 **CSS 파일**을 연결해두었지만, 실제 실행 시 CSS가 적용되지 않거나 오류가 나는 경우가 있습니다. 주로 발생하는 원인은 **CSS 파일의 경로 문제**입니다. Scene Builder에서는 로컬 절대경로나 프로젝트 상대경로를 통하여 CSS를 미리보기로 적용하지만, 애플리케이션 실행 시에는 CSS가 **클래스패스**에서 로드됩니다. 예를 들어 `styles.css` 파일을 _Scene Builder_에서 연결하면 FXML에 `<AnchorPane stylesheets="@../style/app.css">` 같은 경로로 저장될 수 있는데, 이를 실행 시 FXMLLoader가 찾지 못하면 다음과 같은 예외가 발생합니다: _“Invalid resource: ../style/app.css not found on the classpath”_ ([scenebuilder - Connected styles in Scene Builder is not found in runtime - Stack Overflow](https://stackoverflow.com/questions/53309349/connected-styles-in-scene-builder-is-not-found-in-runtime#:~:text=I%20create%20,not%20found%20on%20the%20classpath)). 즉, FXML에 지정된 경로가 클래스패스 기준으로 올바르지 않으면 CSS가 적용되지 않고 기본 스타일로 보이게 됩니다 (이 때문에 Scene Builder 미리보기와 실행 모습이 달라집니다).

**해결:** **CSS 파일을 프로젝트 리소스 경로에 포함**시키고, FXML이나 코드에서 **올바른 경로로 참조**해야 합니다. 일반적으로 `src/main/resources` 아래에 CSS를 두었다면 FXML에서 `stylesheets="@/style/app.css"`처럼 슬래시(`/`)로 시작하는 경로를 사용해 클래스패스 루트 기준 경로로 지정하면 제대로 로드됩니다 ([scenebuilder - Connected styles in Scene Builder is not found in runtime - Stack Overflow](https://stackoverflow.com/questions/53309349/connected-styles-in-scene-builder-is-not-found-in-runtime#:~:text=While%20manually%20editing%20the%20FXML,and%20removing%20the%20parent%20dots)). 위 예시의 문제를 해결하기 위해서는 FXML의 경로를 `@/style/app.css`로 고쳐주면 경로 해석이 올바르게 이루어집니다. 또는 Java 코드에서 CSS를 추가하는 방법도 있습니다:

```java
Scene scene = new Scene(root);
scene.getStylesheets().add(
    MainApp.class.getResource("/style/app.css").toExternalForm()
);
```

위와 같이 `Class.getResource("/...")`로 클래스패스 리소스를 불러와 `Scene`에 추가하면 경로 문제없이 CSS가 적용됩니다 ([scenebuilder - Connected styles in Scene Builder is not found in runtime - Stack Overflow](https://stackoverflow.com/questions/53309349/connected-styles-in-scene-builder-is-not-found-in-runtime#:~:text=,fxml%2Fscene.fxml)). 중요한 점은, **FXML에 상대경로(`../`)를 사용하면 Scene Builder 미리보기에는 편리하지만 런타임에는 문제가 될 수 있으므로 피하는 것**이 좋습니다 ([scenebuilder - Connected styles in Scene Builder is not found in runtime - Stack Overflow](https://stackoverflow.com/questions/53309349/connected-styles-in-scene-builder-is-not-found-in-runtime#:~:text=null%2F,not%20found)). 만약 FXML을 수정하지 않고도 문제를 해결하고 싶다면, FXMLLoader로 FXML을 로드할 때 `FXMLLoader.load(클래스명.class.getResource("경로"))`를 사용하여 **클래스 기준 경로**를 정확히 지정해야 합니다 ([scenebuilder - Connected styles in Scene Builder is not found in runtime - Stack Overflow](https://stackoverflow.com/questions/53309349/connected-styles-in-scene-builder-is-not-found-in-runtime#:~:text=,fxml%2Fscene.fxml)). 요약하면, **CSS 파일은 실행 시 접근 가능한 경로에 위치**해야 하며, **FXML이나 코드에서 그 경로를 정확히 참조**하도록 해야 Scene Builder에서 본 스타일이 그대로 적용됩니다.

## 4. **레이아웃 컨테이너 설정 및 배치 문제**

**원인:** Scene Builder에서 UI를 배치할 때 사용한 **레이아웃 컨테이너의 제약 조건**이 올바르게 적용되지 않으면 실행 시 배치가 달라집니다. 가장 흔한 사례로 **AnchorPane**에 절대 좌표로 배치한 경우를 들 수 있습니다. AnchorPane은 자식 노드의 `layoutX`, `layoutY`로 위치를 고정하는데, Scene Builder 미리보기에서는 특정 크기 창에 딱 맞춰 보여주지만, 실제 실행 시 창 크기가 달라지면 컨테이너가 자동으로 크기 변화를 반영하지 않습니다 ([java - Why does this JavaFX application look way different than when it's in SceneBuilder? - Stack Overflow](https://stackoverflow.com/questions/59586746/why-does-this-javafx-application-look-way-different-than-when-its-in-scenebuild#:~:text=Two%20reasons%3A%20,preferred%20dimensions%20of%20the%20root)). 예를 들어 Scene Builder에서 AnchorPane의 prefWidth=600으로 디자인하고 버튼을 `layoutX=500`에 두었다면, 정작 실행한 창이 더 넓으면 버튼이 오른쪽으로 치우쳐 보일 수 있습니다. 또는 AnchorPane을 사용하면서 부모 창 크기에 맞추도록 앵커(anchor)를 설정하지 않으면 **창 크기 변경 시 빈 여백**이 생기거나 배치가 틀어집니다 ([java - Why does this JavaFX application look way different than when it's in SceneBuilder? - Stack Overflow](https://stackoverflow.com/questions/59586746/why-does-this-javafx-application-look-way-different-than-when-its-in-scenebuild#:~:text=Two%20reasons%3A%20,preferred%20dimensions%20of%20the%20root)). VBox, HBox 같은 레이아웃도 `hgrow`, `vgrow` 등의 속성 설정에 따라 달리 동작하므로, 미리보기에서는 괜찮았지만 실제로는 늘어나는 공간을 활용하지 못해 정렬이 어긋날 수 있습니다.

**해결:** 레이아웃 문제를 줄이기 위해 **반응형 레이아웃 컨테이너**를 올바르게 사용해야 합니다. 가능하면 고정 좌표 배치보다는 **VBox/HBox, GridPane, BorderPane** 등 **크기에 따라 자동 정렬**을 지원하는 컨테이너를 사용합니다 ([10 Bizarre Bugs Encountered by JavaFX Developers and How to Fix Them | MoldStud](https://moldstud.com/articles/p-10-bizarre-bugs-encountered-by-javafx-developers-and-how-to-fix-them#:~:text=5,Windows)). 반드시 AnchorPane을 써야 한다면, 자식 노드에 `AnchorPane.topAnchor`, `leftAnchor`, `rightAnchor`, `bottomAnchor` 값을 지정하여 **부모 경계에 붙도록** 설정합니다. 예를 들어, AnchorPane 전체를 채우는 Pane이라면 `AnchorPane.leftAnchor="0.0"` 등의 속성을 줘서 창 크기 변화에 따라 같이 크기가 변하도록 해야 합니다. 또한 **Stage의 초기 크기를 Scene Builder의 디자인 크기와 일치**시키거나, `Stage.setResizable(false)`로 고정 크기 창으로 만들면 Scene Builder에서 본 모양과 실행 모양의 차이가 줄어듭니다. 반대로 **유연한 크기 조절**이 목적이라면, Scene Builder 미리보기에서 Ctrl+P (미리보기 창)로 **여러 크기**로 테스트해보고 컴포넌트가 흐트러지지 않는지 검증해야 합니다 ([Preview window and actual window different sizes : r/JavaFX](https://www.reddit.com/r/JavaFX/comments/a0ryer/preview_window_and_actual_window_different_sizes/#:~:text=I%20am%20trying%20to%20create,how%20I%20can%20fix%20this)).

실제 사례로, AnchorPane에 고정 크기로 배치한 UI를 400×400 창으로 미리보기했지만, 실행할 때 `Scene`을 600×400으로 설정하여 띄운다면 여백이 생기고 위치가 어긋납니다 ([java - Why does this JavaFX application look way different than when it's in SceneBuilder? - Stack Overflow](https://stackoverflow.com/questions/59586746/why-does-this-javafx-application-look-way-different-than-when-its-in-scenebuild#:~:text=Two%20reasons%3A%20,preferred%20dimensions%20of%20the%20root)). 이때 해결 방법은 **Scene의 크기를 지정하지 않고** 콘텐츠의 pref 크기에 맞게 하거나 (`new Scene(root)`), AnchorPane 대신 **BorderPane** 등을 사용하여 중앙에 배치하는 것입니다. **요약:** Scene Builder 디자인과 실행 UI의 레이아웃 차이를 없애려면 **레이아웃 제약을 명시적으로 지정**하고, **창 크기 설정을 디자인에 맞추거나 유연하게 처리**해야 합니다.

## 5. **폰트 및 플랫폼 차이**

**원인:** 운영체제나 JDK 버전에 따라 **기본 폰트 렌더링과 테마**가 달라, UI가 미세하게 차이날 수 있습니다. 예를 들어 Windows의 기본 폰트와 macOS의 기본 폰트는 크기와 자간이 달라서, 같은 FXML이라도 macOS에서 실행하면 라벨이나 버튼 크기가 약간 다를 수 있습니다. Scene Builder 자체는 JavaFX Modena 테마를 사용해 미리보기를 제공하지만, 실제 애플리케이션이 **다른 CSS 테마**를 적용하거나 **OS 테마** 영향을 받으면 색상이나 여백이 다르게 보일 수도 있습니다 ([10 Bizarre Bugs Encountered by JavaFX Developers and How to Fix Them | MoldStud](https://moldstud.com/articles/p-10-bizarre-bugs-encountered-by-javafx-developers-and-how-to-fix-them#:~:text=2)). 또한 JavaFX 8 vs JavaFX 11의 Modena 테마는 거의 같지만, 만약 구버전 **Caspian 테마**를 강제로 쓰는 경우(매우 드문 경우지만) Scene Builder 미리보기와 괴리가 생길 수 있습니다. 폰트의 경우, 일본어나 한글 등의 **글꼴 대체** 이슈로 Scene Builder에 없는 글꼴이 사용되면 대체 폰트로 보이면서 크기가 달라질 가능성도 있습니다.

**해결:** **일관된 폰트와 스타일**을 사용하도록 강제하면 플랫폼 간 차이를 줄일 수 있습니다. 예를 들어 CSS에 `-fx-font-family`를 지정하여 모든 플랫폼에서 동일한 글꼴을 쓰도록 하거나, 필요하면 애플리케이션과 함께 TrueType 폰트 파일을 배포해 임베디드 폰트를 사용합니다. 또한 **여백(margin/padding)**을 넉넉히 주어 폰트 렌더링 오차 범위 내에서도 레이아웃이 깨지지 않도록 설계하는 것이 좋습니다. Scene Builder에서 **Preview > Preview in Window** 기능으로 현재 OS에서의 모양을 볼 수 있지만, 가능하면 Windows, macOS, Linux 등 **여러 플랫폼에서 테스트**해보는 것이 안전합니다 ([10 Bizarre Bugs Encountered by JavaFX Developers and How to Fix Them | MoldStud](https://moldstud.com/articles/p-10-bizarre-bugs-encountered-by-javafx-developers-and-how-to-fix-them#:~:text=Another%20common%20issue%20with%20JavaFX,multiple%20platforms%20to%20ensure%20consistency)). 테마 측면에서는, **애플리케이션에서 사용하는 CSS를 Scene Builder에서도 불러오기**(미리보기 CSS 지정)하여 최대한 동일한 스타일로 디자인합니다. 예를 들어 Darcula 같은 테마를 적용할 예정이라면, Scene Builder에서 해당 CSS를 임포트해보는 식입니다. 마지막으로 JDK/JavaFX 업데이트에 따라 기본 스타일이 미묘하게 달라질 수 있으므로, **JavaFX 릴리스 노트**를 확인해 컨트롤의 기본 크기나 폰트 변경사항이 있는지 살피는 것도 권장됩니다.

---

以上の 원인별 대처법을 통해 **Scene Builder 미리보기와 실제 실행 UI의 괴리**를 상당 부분 해소할 수 있습니다. 요약하면, **개발 환경(버전, DPI)**을 맞추고, **리소스 경로(CSS 등)**를 올바르게 관리하며, **레이아웃을 유연하게 설계**하는 것이 핵심입니다. 다음으로, Scene Builder 이외에 **디자인과 실행 화면의 일치도가 높은** 다른 JavaFX UI 설계 도구들이 있는지 살펴보겠습니다.

## 2. Scene Builder 대안: 실행 화면 일치도가 높은 JavaFX UI 설계 도구

JavaFX용 GUI 빌더로는 Scene Builder가 가장 널리 쓰이지만, 일부 개발자는 다른 도구를 활용하기도 합니다. 여기서는 **IntelliJ IDEA의 내장 UI 디자이너**, **JFoenix 라이브러리 활용**, **JFormDesigner** 등을 소개하고, 각 도구의 사용 방법을 단계별로 설명합니다. 또한 각 도구의 **장단점 비교표**를 통해 어떤 상황에 적합한지 판단할 수 있도록 하였습니다.

### 1. IntelliJ IDEA 내장 JavaFX 디자이너

IntelliJ IDEA에서는 별도의 플러그인이나 설정을 통해 **Scene Builder를 IDE에 통합**하여 사용할 수 있습니다. 마치 Android Studio에서 레이아웃을 디자인하듯이, IntelliJ에서도 FXML을 열면 코드 편집기와 디자인 편집기를 **빠르게 전환**할 수 있습니다 ([java - JavaFX SceneBuilder alternative - Stack Overflow](https://stackoverflow.com/questions/48126304/javafx-scenebuilder-alternative#:~:text=4)). 사실 IntelliJ 자체에 완전히 별개로 구현된 JavaFX 디자이너가 있는 것은 아니고, **Gluon Scene Builder를 내장 창에서 구동**하는 방식입니다. 이를 설정하고 사용하는 단계는 다음과 같습니다:

1. **Scene Builder 설치 경로 지정:** 우선 최신 버전의 **Gluon Scene Builder**를 설치합니다. IntelliJ IDEA에서 `File > Settings > Languages & Frameworks > JavaFX` (또는 Preferences > Languages & Frameworks > JavaFX on macOS)로 이동하여 **Scene Builder Home 경로**를 Scene Builder의 실행 파일 위치로 설정합니다. 이 경로 설정이 완료되면 IntelliJ가 FXML 파일을 열 때 해당 Scene Builder를 사용합니다.
    
2. **FXML 파일 열기:** 프로젝트의 FXML 파일을 열면 하단에 탭으로 **Text**와 **Scene Builder** 두 가지 보기가 나타납니다. 기본은 XML Text 편집이며, **Scene Builder 탭**을 누르면 해당 FXML을 Scene Builder UI로 편집할 수 있는 모드로 전환됩니다. 만약 탭이 보이지 않으면 FXML 파일을 마우스 오른쪽 클릭하여 *"Open in SceneBuilder"*를 선택하면 됩니다. IntelliJ Ultimate의 경우 Scene Builder가 IDE 안에 임베드되어 나타나고, Community Edition은 외부 Scene Builder 창이 뜨는 방식일 수 있습니다.
    
3. **UI 편집 및 코드 연동:** Scene Builder 모드에서 레이아웃을 수정하면 즉시 FXML 소스에 반영되며, 코드에서 컨트롤러와 연결된 fx:id나 onAction 등을 IntelliJ에서 바로 인식합니다. 디자인 작업 후 **Ctrl+S** (저장) 하면 FXML이 업데이트되고, 곧바로 프로젝트를 실행하여 결과를 확인할 수 있습니다. 디자인-코드-실행 사이클이 IDE 내에서 원활하게 돌아가기 때문에 생산성이 높아집니다.
    

**장점:** IntelliJ 통합 디자이너의 가장 큰 장점은 **개발 흐름의 일체감**입니다. 디자인 변경과 코드 수정을 IDE 하나에서 할 수 있어 편리하고, Android Studio와 유사한 사용자 경험을 제공합니다 ([java - JavaFX SceneBuilder alternative - Stack Overflow](https://stackoverflow.com/questions/48126304/javafx-scenebuilder-alternative#:~:text=4)). 또한 컨트롤러 코드 작성 시 자동 완성 지원이나 fx:id 동기화 등 IDE의 이점을 그대로 활용할 수 있습니다. **레이아웃 미리보기**도 IDE 내에서 바로 실행해볼 수 있어(또는 단축키로 Scene Builder 미리보기) 디자인과 실행의 차이를 수시로 점검하기 수월합니다.

**단점:** 통합된 Scene Builder도 근본적으로 Gluon Scene Builder를 사용하므로, **Scene Builder 자체의 한계(DPI 이슈 등)**는 그대로 존재합니다. 예를 들어 고DPI 환경에서 통합 Scene Builder UI가 흐리게 보이는 문제는 VM 옵션(`-Dsun.java2d.uiScale.enabled=false` 등)으로 조정해야 할 수 있습니다 ([java - Intellij IDEA JavaFX Scene Builder different resolution to the rest of the application - Stack Overflow](https://stackoverflow.com/questions/50003269/intellij-idea-javafx-scene-builder-different-resolution-to-the-rest-of-the-appli/50009067#:~:text=It%27s%20a%20known%20issue)). 또한 IntelliJ Community Edition에서는 기본적으로 JavaFX FXML 디자이너가 포함되지 않아 설정이 다소 번거롭고, Ultimate에서만 완전한 통합이 가능합니다. 그럼에도 불구하고 별도 프로그램 전환 없이 작업할 수 있다는 점에서 IntelliJ 연동은 유용한 대안입니다.

### 2. JFoenix 기반 Material Design 디자인

**JFoenix**는 JavaFX 용 **Material Design UI 컴포넌트 라이브러리**입니다. 자체적인 UI 디자이너 툴이라기보다는 **Scene Builder에서 사용할 수 있는 커스텀 컨트롤 모음**이지만, 이를 활용하면 디자인과 실제 실행 화면 간의 차이를 줄이는 동시에 세련된 일관성있는 스타일을 얻을 수 있습니다. 특히 **Material Design 가이드라인**에 맞춘 컴포넌트들이 제공되므로, 각 OS마다 다르게 보일 수 있는 기본 컨트롤 대신 동일한 스타일의 컨트롤을 사용할 수 있습니다.

Scene Builder에서 JFoenix를 사용하는 방법은 다음과 같습니다:

1. **JFoenix 라이브러리 추가:** JFoenix의 JAR 파일을 다운로드합니다 (Java 8용과 Java 9+용 버전이 다르므로 자신의 JavaFX 버전에 맞는 것을 선택). Scene Builder를 열고 상단 메뉴에서 **Library > Import JAR/FXML** (또는 사용자 라이브러리 추가)을 선택한 뒤, 다운로드한 `JFoenix.jar` 파일을 추가합니다 ([java - JavaFX SceneBuilder alternative - Stack Overflow](https://stackoverflow.com/questions/48126304/javafx-scenebuilder-alternative#:~:text=0)). 그러면 Scene Builder의 왼쪽 패널(Library)에 _Custom_ 섹션 아래 JFoenix의 컨트롤들이 나타납니다.
    
2. **디자인에 JFoenix 컨트롤 사용:** 예를 들어 일반 `Button` 대신 `JFXButton`, `TextField` 대신 `JFXTextField` 등을 드래그하여 배치합니다. 이 컨트롤들은 기본 JavaFX Modena 테마 대신 **Material Design 스타일**로 렌더링되며, Scene Builder 미리보기에서도 해당 스타일이 적용되어 보입니다. 그림자 효과나 리플(ripple) 효과 등도 미리 확인할 수 있습니다. JFoenix 컨트롤을 사용하면 Scene Builder 미리보기와 실제 실행 시의 모습이 거의 동일하며, 기본 테마와 달리 **OS에 상관없이 동일한 디자인**이 유지됩니다.
    
3. **프로젝트에 JFoenix 적용:** FXML에 JFoenix 컨트롤을 추가하면 해당 FXML 최상단에 `<?import com.jfoenix.controls.JFXButton?>` 등의 임포트 구문이 생깁니다. 이제 애플리케이션 코드나 빌드 설정에서 JFoenix 라이브러리를 포함시켜야 합니다. Maven이나 Gradle을 사용한다면 `com.jfoenix` 의존성을 추가하고, 직접 JAR을 사용한다면 클래스패스에 JFoenix.jar를 넣습니다. 그리고 **JFoenix CSS**를 적용하려면, JFoenix에서 제공하는 `JFXDecorator`, `JFoenixDesign.css` 등을 사용하거나 각 컨트롤의 기본 속성을 이용하면 됩니다 (대부분의 경우 별도 CSS 없이도 기본 Material 스타일이 적용됨).
    

**장점:** JFoenix를 사용하면 **디자인의 일관성**을 높일 수 있습니다. Scene Builder에서 본 것과 동일한 Material Design 룩이 실제 앱에 적용되므로 “디자인과 실행의 괴리”가 줄어듭니다. 특히 기본 JavaFX 컨트롤의 테마는 OS 폰트나 렌더링에 영향을 받지만, JFoenix는 커스텀 스타일이기에 **Windows, macOS 모두 동일한 모양**을 보입니다. 또한 모던한 UI/UX를 쉽게 구현할 수 있어 애플리케이션의 품질이 향상됩니다.

**단점:** 추가 라이브러리를 써야 하므로 **프로젝트 종속성이 늘어나고** 관리 포인트가 증가합니다. JFoenix 컨트롤은 기본 컨트롤과 API 사용법이 거의 비슷하지만, 그래도 일부 속성이나 이벤트명이 다를 수 있어 학습이 필요합니다. 또한 Scene Builder에 임포트하여 쓰는 방식이기 때문에 **Scene Builder 호환성**이 중요합니다 (예: JFoenix 버전에 따라 Scene Builder 8.x용, 11.x용이 따로 있음). 마지막으로 JFoenix 프로젝트가 한때 업데이트가 더디었던 적이 있어 (현재는 커뮤니티 포크 등으로 유지보수되고 있음), 장기적인 호환성을 확인하는 것이 좋습니다. 그럼에도 **Scene Builder + JFoenix 조합**은 현재 디자인 대비 실행 화면 불일치를 최소화하면서 현대적인 디자인을 얻는 좋은 방법으로 권장됩니다 ([java - JavaFX SceneBuilder alternative - Stack Overflow](https://stackoverflow.com/questions/48126304/javafx-scenebuilder-alternative#:~:text=0)).

### 3. JFormDesigner를 이용한 JavaFX GUI 디자인

**JFormDesigner**는 원래 Swing UI 디자이너로 유명한 **상용 GUI 디자인 도구**인데, 최신 버전(9 EA)부터 **JavaFX 폼 디자인**을 지원하고 있습니다 ([JFormDesigner 9 EA for JavaFX | JFormDesigner - Java/Swing GUI Designer](https://www.formdev.com/jformdesigner/javafx/#:~:text=JFormDesigner%209%20is%20in%20active,development%20and%20not%20feature%20complete)). Scene Builder처럼 FXML을 편집하는 것은 아니지만, **드래그&드롭 WYSIWYG 편집기**로 UI를 설계하면 JavaFX 코드를 자동 생성해주는 방식입니다. JFormDesigner는 독립 실행형 애플리케이션으로 사용하거나 IntelliJ/Eclipse 등의 IDE 플러그인으로 설치할 수 있습니다. JavaFX 개발에서 활용하는 절차는 다음과 같습니다:

1. **JFormDesigner 설치:** 공식 사이트에서 JFormDesigner를 다운로드하여 설치합니다. 평가판을 사용할 수도 있고, IntelliJ나 Eclipse의 Plugin Marketplace/Update Site에서 바로 설치할 수도 있습니다.
    
2. **새 JavaFX 폼 생성:** JFormDesigner를 열고 **New Form**을 만들 때 UI 툴킷으로 **JavaFX**를 선택합니다 ([JFormDesigner 9 EA for JavaFX | JFormDesigner - Java/Swing GUI Designer](https://www.formdev.com/jformdesigner/javafx/#:~:text=To%20start%20designing%20JavaFX%20forms%2C,in%20the%20New%20Form%20dialog)). 그러면 `.jfd` 확장자의 디자이너 전용 파일과 함께 `.java` 파일이 생성됩니다. 예를 들어 _MainView.jfd_와 _MainView.java_가 생성되고, .java 파일에 해당 UI를 구성하는 Java 코드가 들어갑니다 (FXML을 생성하는 모드도 추후 지원 예정이나, 현재는 **Java 코드 생성** 방식입니다 ([JFormDesigner 9 EA for JavaFX | JFormDesigner - Java/Swing GUI Designer](https://www.formdev.com/jformdesigner/javafx/#:~:text=code%20to%20create%20the%20JavaFX,form))).
    
3. **UI 디자인:** JFormDesigner의 편집 화면에서 Stage(Scene) 크기와 컨테이너, 컨트롤을 배치합니다. Scene Builder와 유사한 속성 패널이 있으며, 컨트롤의 속성을 설정하면 즉시 미리보기 화면에 반영됩니다. 레이아웃으로 GridPane, BorderPane 등 JavaFX 기본 패널 외에 **MigPane**(MigLayout의 JavaFX 버전) 같은 고급 레이아웃도 지원합니다 ([JFormDesigner 9 EA for JavaFX | JFormDesigner - Java/Swing GUI Designer](https://www.formdev.com/jformdesigner/javafx/#:~:text=Image)). MigLayout을 쓰면 복잡한 폼 레이아웃을 수월하게 잡을 수 있다는 점이 Scene Builder 대비 장점입니다. 디자인을 완료하면 _저장_하여 .jfd/.java를 업데이트합니다.
    
4. **생성된 코드 사용:** JFormDesigner가 생성한 .java 파일은 보통 특정 패키지의 클래스로 정의되며, 내부에 `initializeComponents()` 메서드 등을 통해 버튼, 레이블 등을 배치하는 코드가 포함됩니다. 이 클래스를 애플리케이션에서 직접 사용하거나, 컨트롤러처럼 인스턴스화하여 Scene에 추가하면 됩니다. 즉, FXML을 로드하는 대신 `new MainView(); Scene scene = new Scene(mainView.getRoot());` 이런 식으로 생성된 UI를 사용할 수 있습니다. 생성 코드는 사람이 수정하지 않는 것이 권장되며, 다시 디자이너로 편집하면 변경사항이 덮어쓰여집니다.
    

**장점:** JFormDesigner를 쓰면 **IDE와 밀접하게 통합**되어 편리합니다 (IntelliJ, Eclipse 플러그인 제공). 또한 **복잡한 레이아웃**을 세밀하게 구성하는 데 강점이 있으며, Swing 디자이너로 오랜 기간 다듬어진 기능들(스냅, 정렬 안내선, 다국어 리소스 편집 등)이 JavaFX 디자인에도 일부 적용됩니다. MigLayout 같은 강력한 레이아웃을 쓸 수 있다는 것은 Scene Builder 대비 차별점으로, 폼 형태 UI를 만드는 데 유리합니다 ([JFormDesigner 9 EA for JavaFX | JFormDesigner - Java/Swing GUI Designer](https://www.formdev.com/jformdesigner/javafx/#:~:text=Image)). 그리고 디자인한 결과가 **Java 코드로 바로 생성**되므로 별도의 FXML 로딩 단계 없이도 실행 화면을 얻을 수 있습니다 (런타임에 FXML 오류가 발생할 여지가 없음).

**단점:** 상용 제품으로 **라이선스 비용**이 듭니다 (기업용/개인용 구매 필요, 평가판 기간 제한). 또한 현재 JavaFX 지원이 완전하지 않아 **FXML 직접 편집이나 출력은 불가능**합니다 ([JFormDesigner 9 EA for JavaFX | JFormDesigner - Java/Swing GUI Designer](https://www.formdev.com/jformdesigner/javafx/#:~:text=code%20to%20create%20the%20JavaFX,form)). 즉, FXML을 선호하는 개발자에겐 맞지 않을 수 있고, 생성된 Java 코드를 커스터마이징하기도 어렵습니다. 그리고 Scene Builder만큼 커뮤니티 정보가 많지 않아서 초반 학습이 필요합니다. 마지막으로, JFormDesigner의 JavaFX 지원은 아직 Early Access 단계이므로 일부 컨트롤이나 기능이 누락되어 있을 수 있습니다 (예: Menu, Chart 등은 지원 예정 목록에 있음 ([JFormDesigner 9 EA for JavaFX | JFormDesigner - Java/Swing GUI Designer](https://www.formdev.com/jformdesigner/javafx/#:~:text=,color))). 그럼에도 **GUI 배치 정확도**나 **복잡한 UI 구성** 측면에서는 Scene Builder보다 뛰어난 면이 있어, 큰 폼 기반 앱을 만드는 경우 고려할 만합니다.

### 4. 기타 도구 및 요약

이 밖에도 **Oracle NetBeans** IDE는 과거에 JavaFX Composer를 통합하여 FXML 편집을 지원했으며, 현재는 Scene Builder를 외부 연동하는 방식으로 지원합니다. **Eclipse** 역시 e(fx)clipse 플러그인을 통해 FXML 편집과 미리보기 기능을 제공합니다. 다만 이들 역시 내부적으로 Scene Builder를 연동하는 형태이므로 Scene Builder와 큰 차이는 없습니다. 한편, FXML이 아닌 **코드 기반 UI 작성**도 하나의 대안인데, 이 경우 IDE의 실시간 미리보기는 없지만 레이아웃을 코드로 제어하기 때문에 실행 결과에 대한 신뢰도가 높습니다 (디자인과 실제 불일치가 애초에 발생하지 않음). 그러나 코드로 UI를 구성하는 것은 생산성이 떨어질 수 있으므로, 소규모 UI나 동적 UI 구성에 한해 활용됩니다.

아래 표는 앞서 언급한 JavaFX UI 설계 도구들의 주요 **장점과 단점**을 비교한 것입니다:

|도구|장점|단점|
|---|---|---|
|**Gluon Scene Builder** (기본)|_- Oracle/Gluon 공식 FXML 디자이너로 광범위한 사용자층- FXML 코드와 미리보기가 연동되어 직관적 편집- 무료 오픈소스, 경량 툴_|_- 고DPI 대응 미흡 등 몇 가지 버그 ([java - JavaFX scene scales differently in Scene builder and run time on Windows 10 - Stack Overflow](https://stackoverflow.com/questions/43195515/javafx-scene-scales-differently-in-scene-builder-and-run-time-on-windows-10#:~:text=I%20using%20Scene%20Builder%20with,setting%20the%20scene%20size%201280x800)) ([Java: Is it possible to disable Windows DPI scaling from within java? - Stack Overflow](https://stackoverflow.com/questions/30824996/java-is-it-possible-to-disable-windows-dpi-scaling-from-within-java#:~:text=4))- 복잡한 레이아웃 작성 기능 제한- 디자인 결과가 DPI나 플랫폼에 따라 다르게 보일 수 있음_|
|**IntelliJ IDEA 통합 디자이너**|_- IDE 내장으로 디자인-코딩 전환 용이 ([java - JavaFX SceneBuilder alternative - Stack Overflow](https://stackoverflow.com/questions/48126304/javafx-scenebuilder-alternative#:~:text=4))- 컨트롤러 코드 연계, 자동완성 등 개발 편의 높음- Android Studio와 유사한 UX_|_- Scene Builder 엔진을 사용하므로 기본 Scene Builder 한계 동일- IntelliJ Ultimate에서 최적 (Community는 외부 SB 사용)- 고DPI 환경에서 IDE설정 추가 필요 ([java - Intellij IDEA JavaFX Scene Builder different resolution to the rest of the application - Stack Overflow](https://stackoverflow.com/questions/50003269/intellij-idea-javafx-scene-builder-different-resolution-to-the-rest-of-the-appli/50009067#:~:text=It%27s%20a%20known%20issue))_|
|**Scene Builder + JFoenix**|_- Material Design 등 현대적 UI를 손쉽게 구현- 모든 플랫폼에서 일관된 룩 앤 필 제공 ([java - JavaFX SceneBuilder alternative - Stack Overflow](https://stackoverflow.com/questions/48126304/javafx-scenebuilder-alternative#:~:text=0))- Scene Builder에서 커스텀 컨트롤로 바로 사용 가능_|_- 서드파티 라이브러리 의존 (프로젝트 빌드 설정 필요)- JFoenix 특정 버전에 SB 호환성 필요- 컨트롤 특성이 기본 JavaFX와 달라 학습 필요_|
|**JFormDesigner (JavaFX)**|*- 강력한 WYSIWYG 편집 기능 (스냅, 정렬 등)- GridPane뿐 아니라 MigLayout 등 지원 ([JFormDesigner 9 EA for JavaFX|JFormDesigner - Java/Swing GUI Designer]([https://www.formdev.com/jformdesigner/javafx/#:~:text=Image](https://www.formdev.com/jformdesigner/javafx/#:~:text=Image)))- IDE 플러그인으로 통합 가능, Swing 디자인도 겸함*|

_비고:_ 상기 비교에서 **Scene Builder**는 단독 실행 기준이며, IntelliJ/NetBeans/Eclipse 등에서 연동하여 사용할 경우 IDE의 편의성 장점을 추가로 누릴 수 있습니다. **JFoenix**는 Scene Builder의 보완재로서, MaterialFX 등의 유사 라이브러리도 존재합니다. **JFormDesigner**의 JavaFX 지원은 발전 중이므로, 향후 FXML 지원이 추가된다면 더욱 유용해질 것입니다.

## 결론

JavaFX UI 디자인 단계에서 **Scene Builder의 미리보기와 실제 실행 결과의 차이**로 겪는 불편함은 다양한 원인에서 비롯되지만, 각 원인에 맞는 해결책을 적용하면 상당 부분 완화할 수 있습니다. JavaFX 및 JDK 버전을 통일하고, DPI 스케일링을 조정하며, CSS 경로를 올바르게 설정하고, 레이아웃 제약을 세심하게 다듬는 것이 핵심입니다. 또한 Scene Builder 외에도 IntelliJ IDEA의 통합 디자이너를 활용하면 개발 효율을 높일 수 있고, JFoenix 라이브러리를 통해 디자인 퀄리티와 일치도를 동시에 잡을 수 있습니다. JFormDesigner와 같은 전문 GUI 디자이너 툴은 초기 세팅과 비용의 단점이 있지만 복잡한 UI 설계에 도움이 될 수 있습니다.

**요약하면:** 기존 Scene Builder를 사용할 경우, 개발 환경 설정과 레이아웃 기법을 최적화하여 **“디자인 = 실행”**에 가깝게 만들고, 필요에 따라 다른 도구나 라이브러리를 병행함으로써 **일관된 UI/UX**를 확보하는 전략이 필요합니다. 이를 통해 Scene Builder의 한계를 보완하고, 최종 프로그램에서 디자인 의도를 100% 반영할 수 있을 것입니다. ([java - JavaFX scene scales differently in Scene builder and run time on Windows 10 - Stack Overflow](https://stackoverflow.com/questions/43195515/javafx-scene-scales-differently-in-scene-builder-and-run-time-on-windows-10#:~:text=I%20using%20Scene%20Builder%20with,setting%20the%20scene%20size%201280x800)) ([Java: Is it possible to disable Windows DPI scaling from within java? - Stack Overflow](https://stackoverflow.com/questions/30824996/java-is-it-possible-to-disable-windows-dpi-scaling-from-within-java#:~:text=4))