좋습니다. 재해문자전광판 프로토콜 정의서를 기반으로, 다빛솔루션의 전광판 시스템에서

1. 프로토콜 명세대로 그대로 전송하는 방식,
    
2. 다빛솔루션 고유 ASCII 프로토콜로 변환 후 중계하는 방식 두 시나리오 각각에 대해 구현에 필요한 요구사항, 고려사항, 변환 로직, 프로토콜 호환성 등을 자세히 분석해드리겠습니다.
    

잠시만 기다려 주세요. 곧 상세한 자료로 안내드리겠습니다.

# 행안부 재해문자전광판 프로토콜 적용을 위한 구현 방안 분석

## 개요

행정안전부의 **“재해문자전광판 프로토콜 정의서”**에는 옛 버전 **구프로토콜**과 개선된 **신프로토콜** 두 가지 통신 규약이 정의되어 있습니다 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=,%20%20%20-ei16pxxfup3covp1m3oulizp8h8r0atn4bzfe/)). 다빛솔루션 전광판 시스템에 이 프로토콜을 적용하는 방법으로, **① MOIS 표준 프로토콜(신/구)을 그대로 구현하여 직접 전광판으로 전송**하거나 **② MOIS 프로토콜 메시지를 해석(파싱)한 후 다빛솔루션 고유 ASCII 기반 프로토콜로 변환 중계**하는 두 가지 방안을 고려할 수 있습니다. 아래에서는 각 방식의 요구사항과 구현 세부사항, 주의점, 그리고 다빛솔루션 전광판 기준에서의 효율 비교를 기술 가이드 형태로 정리합니다.

## 방식 1: MOIS 표준 프로토콜 직접 전송

### 통신 인터페이스 및 데이터 형식 요구사항

**직접 전송 방식**은 행안부의 정의서를 준수하여 전광판이 **신프로토콜 또는 구프로토콜을 직접 송수신**하도록 전광판 컨트롤러를 구현하는 것입니다. 이 방식에서는 전광판 시스템이 **MOIS 서버와 동일한 인터페이스**를 사용해야 합니다. 예를 들어:

- **통신 인터페이스**: 구프로토콜은 과거에 전화모뎀(PSTN) 기반으로 개발되었으나 현재는 **TCP/IP 이더넷**을 사용합니다. 정의서에는 구/신 프로토콜 별 서버 IP와 포트가 지정되어 있으며 (예: 기존 시스템 구프로토콜 서버 `125.60.28.110:7200`, 신프로토콜 서버 `125.60.28.107:7520` 등) 신규 시스템에서는 IP `27.101.222.239:7200`으로 통합된 예시가 나옵니다 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=%20%20%20%20,-uk98pja270iypey95vla6031ika264ala4vr31zpa61pqa599cra718enk9oqa3842ata7736bua/)) ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=%20%20125,239%207200-ke64sdq8p7grmom3amw8b/)). 전광판이 직접 MOIS 서버에 접속하는 경우 **TCP 클라이언트로 접속**하여 통신해야 합니다. (과거 전화망 환경에서는 서버가 전화를 걸면 전광판이 응답하여 데이터 통신을 시작했으며, 이때 ID를 전송함).
    
- **전송 데이터 형식**: MOIS 프로토콜은 **바이너리 프레임 구조**로, STX/ETX 등 제어코드와 다바이트 필드, 체크섬을 포함합니다. 구프로토콜의 경우 STX로 **0xAB** (비표준 값)를 사용하고, 신프로토콜은 표준 STX **0x02**를 사용합니다 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=stx%201%20byte%201%201,2%204%20hex%20010%20010-qdgg/)). 데이터 필드에 한글이 포함될 수 있는데, 프로토콜 정의에 따르면 전광판은 ASCII(0x20~~0x7F)와 **KS 완성형 한글 코드** 범위(0xB0A1~~0xC8FE 등)를 지원합니다. 따라서 **문자 인코딩**은 EUC-KR(완성형) 기반으로 구현하고, 전광판 펌웨어도 해당 코드표로 글자 출력을 해석할 수 있어야 합니다. 전송은 **Hex 값 기반 바이너리**이므로, 시리얼이나 소켓에서 **바이트 스트림** 형태로 처리해야 하며, ASCII 프로토콜과 달리 사람이 읽을 수 있는 텍스트 명령이 아니라 정해진 위치의 바이트들이 의미를 가지는 구조입니다.
    
- **데이터 포맷 호환성**: 다빛솔루션 전광판이 이 프로토콜을 직접 수용하려면, 기존 ASCII 명령처리부 외에 **MOIS 프레임 파서**를 펌웨어에 추가해야 합니다. 예컨대 기존에 ASCII "`<STX>M01...<ETX>`" 형태로 명령을 받았다면, 이제 **0x02/STX**부터 시작하는 바이너리 패킷을 인식하는 모드를 가져야 합니다. 경우에 따라 **두 프로토콜을 모두 지원**해야 할 수도 있습니다 (행안부 신규 시스템도 구/신프로토콜 병행 지원) ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=,%20-6z05o5w8c9jtwk7j/)). 이를 위해 **STX 바이트**를 확인하여 프로토콜 유형을 구분하는 로직이 필요합니다. (0xAB로 시작하면 구프로토콜 패킷, 0x02면 신프로토콜로 처리 등).
    

### 패킷 구조 및 체크섬 처리

MOIS 프로토콜 패킷의 **전체 구조**는 다음과 같습니다:

- **STX** (Start of Text): `1 byte` – 패킷 시작 표시. 구프로토콜=**0xAB**, 신프로토콜=**0x02** ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=stx%201%20byte%201%201,2%204%20hex%20010%20010-qdgg/)).
    
- **LENGTH**: `2 byte` – **데이터 길이 정보**. 두 프로토콜 모두 LENGTH 필드를 사용하나 계산 기준이 다릅니다:
    
    - 구프로토콜: **COMMAND부터 DATA까지**의 바이트수를 LENGTH에 넣습니다. 예를 들어 표시할 문구 데이터가 20바이트이면 COMMAND(1) + DATA(20) = 21(0x15)을 2바이트로 넣습니다 (고지된 Max=900바이트).
        
    - 신프로토콜: **COMMAND부터 CHECKSUM까지**의 바이트수를 LENGTH로 계산합니다. 즉 신프로토콜에서는 패킷 내 **CHECKSUM 이전까지**를 length에 포함하여, 이후 ID 필드까지도 체크섬 계산 대상에 넣는 구조입니다 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=1%20byte%2016%2017%20hex,%20%20low%201%20byte-53436ags8x/)).
        
- **COMMAND**: `1 byte` – 명령어 코드. 구/신 프로토콜 모두 **동일 위치(Length 바로 뒤)**에 명령 코드가 옵니다. 예: 0x10=ID 전송, 0x03=시간 동기화 등. 단, **메시지 전송 관련 명령**은 프로토콜별로 차이가 있습니다 (아래 설명).
    
- **DATA**: `N byte` – 명령어에 따른 가변 길이 데이터. 데이터의 내용과 길이는 COMMAND 종류에 따라 다릅니다. 예를 들어 **ID 전송(0x10)** 명령의 경우 Data가 _모뎀전화번호_이며 구프로토콜에서는 13바이트, 신프로토콜에서는 15바이트 문자열로 정의되어 있습니다 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=stx%201%20byte%201%201,2%204%20hex%20010%20010-qdgg/)) ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=data%2013%20byte%2015%20char,-o075wwu7kbp1a5e59a/)). **문구 전송**의 경우 데이터에 효과코드, 시간정보, 메시지 텍스트 등이 포함되어 비교적 길고 복잡합니다.
    
- **CHECKSUM**: `1 byte` – 데이터 무결성 검증용 합계 값. 계산 범위가 프로토콜마다 다르므로 유의해야 합니다.
    
    - 구프로토콜: **COMMAND부터 DATA 필드 끝까지** 모든 바이트의 합을 구하고, 그 합의 **LOW 1 byte**(하위 1바이트) 값을 넣습니다 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=1%20byte%2016%2017%20hex,%20%20low%201%20byte-53436ags8x/)).
        
    - 신프로토콜: **LENGTH부터 ID 필드까지** 모든 바이트 합의 LOW 1 byte를 사용합니다 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=%20%20low%201%20byte-g868vbr4r/)). 신프로토콜은 LENGTH와 ID까지 포함하여 체크섬을 계산하므로, **전광판 ID까지 올바르게 포함**되지 않으면 체크섬 검증이 실패합니다.
        
- **ID**: `12 byte` – 전광판의 모뎀 ID (전화번호)입니다. 구프로토콜에서는 **일부 상황에서만 사용**되고 일반 데이터 패킷에는 ID가 붙지 않을 수도 있지만, 신프로토콜에서는 **모든 패킷에 ID가 포함**됩니다 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=length%20id%20%20%20low,1%20byte-v029wbz08ag0pc9xxagv2a13ke12t/)). 정의서의 일반 전문 구성표에는 ID가 12바이트 필드로 명시되어 있으며, 신프로토콜 체크섬에 포함되는 것으로 보아 **항상 부가**되는 것으로 해석됩니다.
    
- **ETX** (End of Text): `1 byte` – 패킷 끝 표시로 **0x03** (텍스트 종료 제어문자) 사용 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=id%2012%20byte%2016%20char,1%20byte%2018%20hex%20003-zsg/)).
    

위 구조를 전광판 펌웨어에서 처리하기 위해, **패킷 수신시 고정된 위치의 필드들을 파싱**해야 합니다. 먼저 STX를 확인하여 패킷 시작을 동기화하고, **다음 2바이트 LENGTH를 읽어** 전체 패킷 길이를 파악합니다. 그 후 해당 길이만큼 데이터를 수신한 뒤, **마지막 ETX를 확인**하여 완전한 패킷인지 검증합니다. 체크섬도 수신한 내용으로 직접 계산하여 **CHECKSUM 필드와 일치 여부**를 검사해야 합니다.

> **예시 – ID 전송 패킷 (0x10)**: 신프로토콜에서 전광판이 서버로 최초 접속 시 보내는 ID 패킷은 다음과 같습니다 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=stx%201%20byte%201%201,2%204%20hex%20010%20010-qdgg/)) ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=length%202%20byte%203%20hex,command%20check%20sum%20-1y714aqxbn262gun8cqo4a6gcp13g/)). 가령 전광판 모뎀번호(ID)가 "01012345678"일 경우 (11자리 + 종료문자 등 12byte):
> 
> - STX: `0x02`
>     
> - LENGTH: `0x00 0x10` (16바이트: COMMAND~CHECKSUM까지 길이)
>     
> - COMMAND: `0x10` (ID 전송 명령)
>     
> - DATA: `"01012345678"` + `0x00` (전화번호 문자열 11자리 + null 등 12byte 가량)
>     
> - CHECKSUM: `0x??` (LENGTH부터 ID까지 모든 바이트 합의 LOW 바이트)
>     
> - ID: `"01012345678"` (자신의 전화번호 12자리, 신프로토콜은 패킷에도 ID 포함)
>     
> - ETX: `0x03`  
>     구프로토콜의 경우 STX=0xAB, LENGTH 계산/체크섬 범위가 다르고, 패킷 끝에 별도로 ID를 붙이지 않을 수 있습니다 (ID 자체가 Data로 포함되는 구조) ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=stx%201%20byte%201%201,2%204%20hex%20010%20010-qdgg/)) ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=length%20id%20%20%20low,1%20byte-v029wbz08ag0pc9xxagv2a13ke12t/)).
>     

**문구 전송 명령 구조**도 구체적으로 살펴보겠습니다. 구프로토콜에서는 **COMMAND 0x01**로 문구(메시지)를 전송하며, 데이터 필드에 **표출 설정과 메시지 텍스트**를 담습니다. 신프로토콜에서는 0x01 코드를 사용하지 않고 별도의 **멀티 메시지 전송 절차**를 사용합니다 (COMMAND 0x11 등, 아래 참조). 우선 구프로토콜의 문구 전송 데이터 구성은 다음과 같습니다:

- **방번호** (메시지 슬롯 번호): 1 byte  
    – 1~100 범위의 메시지 인덱스. _(1~5번은 긴급메시지용으로 예약)_. 서버는 메시지를 특정 “방번호”에 저장하도록 지시하며, 전광판은 해당 번호 위치에 메시지를 저장/표출합니다.
    
- **표시효과 코드**: 1 byte  
    – 메시지를 표출할 때 적용할 **시작 효과** (예: 즉시표시, 좌측스크롤 등). 효과 코드 값은 별도의 정의표를 따르며, 0x01~0x0F 범위의 다양한 연출이 존재합니다 (아래 효과 매핑 표 참고).
    
- **표시효과 속도**: 1 byte  
    – 표시 효과의 진행 속도(애니메이션 속도) 설정. 0x01~0x08 범위로 0x01이 가장 빠르고 0x08이 가장 느린 것으로 정의. (예: 스크롤 효과의 속도)
    
- **효과 완료 후 대기시간**: 1 byte  
    – 시작효과가 완료된 후 다음 단계로 넘어가기 전 **대기 시간(정지 시간)**을 1초 단위로 지정.
    
- **완료효과 코드**: 1 byte  
    – 메시지 표시를 종료할 때 적용할 **끝맺음 효과** (예: 서서히 사라짐, 화면반전 등). 시작효과와 마찬가지로 코드로 지정합니다.
    
- **완료효과 속도**: 1 byte  
    – 완료효과 연출 속도 (0x01~0x08, 0x01이 가장 빠름).
    
- **미사용**: 2 byte  
    – 현재 사용되지 않는 예약 필드로 `0x00` 고정. (프로토콜 향후 확장 대비 공간)
    
- **표시 시작 시간**: 5 byte  
    – 해당 메시지를 **시작할 일정 (년월일시분)**. 연도는 1바이트로 0x00=2000년 기준 +N년으로 표시되며, 월/일/시/분 각 1바이트입니다. 만약 즉시 표시해야 하면 현재 시간과 동일하거나 과거로 설정하여 수신 즉시 표시하도록 할 수 있습니다.
    
- **표시 완료 시간**: 5 byte  
    – 메시지를 **종료할 일정 (년월일시분)**. 해당 시간 이후에는 전광판에서 자동으로 이 메시지를 내리도록 예약합니다. (종료 시간이 시작 시간과 동일하면 **상시표시**로 간주될 수 있습니다).
    
- **싸이렌 출력**: 1 byte  
    – 메시지 표출 시 사이렌(경보음)을 울릴지 여부. 값은 ASCII 문자 `'T'`(0x54) 또는 `'F'`(0x46)로 보냅니다. `'T'`일 경우 **해당 메시지가 처음 표시될 때 1회 사이렌음**을 울립니다.
    

이상의 고정 필드(총 19바이트) 다음에 **메시지 텍스트 문자열 데이터**가 이어집니다. 텍스트는 가변길이로, 패킷 **LENGTH 필드에 명시된 바이트 수**만큼 포함됩니다. 한글 문자는 완성형 2바이트로 표현되며, **문자열 종료를 별도로 표시하지 않고** ETX로 패킷이 끝나면 문자열 끝으로 간주합니다. 예를 들어 “비상상황입니다” 라는 메시지가 포함되었다면, 각 글자가 완성형 코드로 변환되어 순서대로 DATA에 실립니다. 구프로토콜은 텍스트 내에서 **특수 제어코드 '!'**를 인식하여 서식/색상 등을 처리할 수 있습니다 (이 부분은 뒤에 설명).

**신프로토콜**은 한 번의 0x01 명령에 모든 것을 보내는 구방식과 달리, **여러 단계에 나누어 전송**하는 방식을 채택합니다 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=,%20%20%20%20-1587pv45a2n3ly6tayml8j2ekgdgw4jyynzxncs9p4gao1d/)). 주요 변경 사항은 다음과 같습니다:

- **멀티 메시지 전송 절차 도입**: 신형 전송에서는 먼저 **“멀티 메시지 방정보 전송” (COMMAND 0x11)** 패킷으로 해당 메시지의 메타정보(슬롯 번호, 효과, 시간, 콘텐츠 종류 등)를 보냅니다 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=11\)%20%20%20%20-hh01ss5ar46evkkyl2e0fpd56er3aj07epj6k/)) ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=%20%20%201byte%2018,1=%20or%20%202=-ku78yfs1iunodnb204eg92fts5a9xdbr9fuezap1t52x6a3729nzc0atbe/)). 이어서 실제 메시지 데이터(텍스트 또는 이미지)를 **여러 분할 패킷**으로 보냅니다. 대용량 데이터를 다수 패킷에 걸쳐 보낸 뒤, 마지막에 **전송 완료 확인 (0x13)**을 주고받는 구조입니다 ([재해문자전광판 프로토콜 정의서.pdf](file://file-bkkbmpttzmn1cyhcthmxt9%23:~:text=/)). 이 과정에서 전광판은 필요 시 **분할 데이터 요청 (예: 0x12)**을 통해 다음 데이터 블록을 요구합니다. 이러한 **Handshaking 절차**로 대용량 콘텐츠 전송의 안정성을 높였습니다. 예를 들어 3컬러 BMP 이미지나 동영상도 이 방식으로 전달 가능합니다 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=%20%20%201byte%2018,1=%20or%20%202=-ku78yfs1iunodnb204eg92fts5a9xdbr9fuezap1t52x6a3729nzc0atbe/)) ([재해문자전광판 프로토콜 정의서.pdf](file://file-bkkbmpttzmn1cyhcthmxt9%23:~:text=char/)).
    
- **콘텐츠 타입 구분**: 0x11 방정보 패킷에는 _멀티메시지 종류_ 필드가 있어서 **콘텐츠 타입**을 구분합니다 (0=3색 BMP 이미지, 1=일반 텍스트/흑백이미지, 2=동영상) ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=%20%20%201byte%2018,1=%20or%20%202=-ku78yfs1iunodnb204eg92fts5a9xdbr9fuezap1t52x6a3729nzc0atbe/)) ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=0=3color%20bmp%20%20%20,1=%20or%20%202=-vr730apq1og99cm65aww1doml8hqb79bly1jm1za/)). 또한 이미지/영상의 경우 **파일 크기, 해상도 등의 추가정보**가 데이터 필드에 포함됩니다. 만약 0x11 패킷에서 이미지 URL이 주어졌다면 전광판이 **직접 웹서버에 접속해 파일을 다운**받는 시나리오도 정의되어 있습니다 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=%20%20%20%20-ni35p5s5r9hyaha5875dia955dda068qoh2dhknlxaea676ywl2l/)) ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=,-e296nv29e/)). (이때 메시지 서버는 전광판에 파일명을 제공하고 전광판이 HTTP로 해당 이미지를 가져오는 방식)
    
- **명령어 변화**: 신프로토콜에서는 구프로토콜의 0x01(문구 전송)과 0x02(방정보 요구) 대신 **0x11, 0x12, 0x13, 0x14** 등이 새로 활용됩니다. 0x14는 **전체 삭제** 명령으로, 구프로토콜의 0x04 대신 신프로토콜에서 사용됩니다 ([재해문자전광판 프로토콜 정의서.pdf](file://file-bkkbmpttzmn1cyhcthmxt9%23:~:text=8/)). 시간 동기화(0x03)와 초기 ID 전송(0x10)은 두 프로토콜에서 공통적으로 사용됩니다. 전광판은 구현 시 어떤 프로토콜 모드를 지원할지 결정하고, 해당 프로토콜의 **모든 관련 명령어 시나리오**를 처리해야 합니다.
    

> **예시 – 신프로토콜 멀티 메시지 전송**: 긴급 메시지 “대피하세요!”를 **1번 방(slot 1)**에 표시하고자 하는 경우, 서버는 다음 순서로 명령을 보냅니다.  
> ① **방정보 전송(0x11)**: 방번호=1, 표시효과=0x02(좌측스크롤) ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=%20%200x01%20%20,%200x08%20%20%20display-nb320a5x0gtcbu73os3yb64j1lszs1l4x7bxtnk4sntj9v7oh01duswb/)) ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=0x02%20%20%200x03%20,display%200x0a%20%20%20change-rx335ana13en69ryh6il7qdsleqpjuylu5mbw8kl60b3kzi/)), 효과속도=0x02 (예: 2초/중간속도), 완료효과=0x05(바로 사라짐) ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=%20%200x05%20%20,%20%200x08%20%20-1j56xd92fkvybea921otx1bljal74cxwq9ja7624aha2689jtbqabgjva8651bka9518j2o8e56saiue/)), 시간정보(즉시시작/별도완료시간 없을 경우 시작시간=현재, 완료시간=0으로 설정), 사이렌='T' 등 메타데이터를 전송. 데이터의 마지막에 멀티메시지종류=1(텍스트) 지정 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=%20%20%201byte%2018,1=%20or%20%202=-ku78yfs1iunodnb204eg92fts5a9xdbr9fuezap1t52x6a3729nzc0atbe/)).  
> ② 전광판이 0x11 패킷 수신 후 **분할전송 요구(0x12)** 응답: 텍스트 내용 길이를 알려주고 다음 데이터 달라고 요청.  
> ③ **데이터 전송(0x13)**: 서버가 “대피하세요!” 문자열 데이터를 전송 (한번에 보낼 수 있는 길이면 한 패킷으로). 완성형 인코딩으로 텍스트 바이트 전송.  
> ④ 전광판이 수신 후 내용 저장, **전송 완료(0x13)** ACK 전송: 서버는 이를 받아 최종 완료 처리.

위 예시처럼, **직접 전송 방식 구현 시**에는 **신/구 각 프로토콜의 패킷 순서와 형식을 정확히 준수**해야 합니다. 특히 신프로토콜은 **여러 단계의 핸드셰이크**가 있으므로, 전광판이 **서버 명령에 맞는 응답 패킷(예: 0x12, 0x13 응답)**을 생성하여 송신하는 로직도 필요합니다. 이는 단순히 수신된 내용을 표시하는 것을 넘어 **통신 프로토콜 스택을 구현**해야 함을 의미합니다.

### 직접 전송 구현 시 고려사항 (체크리스트)

- **LENGTH/체크섬 검증**: 수신 시 LENGTH 필드 기반으로 패킷 경계를 결정하고, CHECKSUM을 반드시 재계산하여 검증합니다. 잘못된 패킷은 무시하거나 오류로 리포트해야 합니다. 특히 신프로토콜의 경우 LENGTH 계산 범위에 유의하여 잘못된 체크섬 산출을 방지합니다 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=1%20byte%2016%2017%20hex,%20%20low%201%20byte-53436ags8x/)). 또한 **패킷 송신 시에도 동일한 방식으로 LENGTH와 CHECKSUM을 정확히 계산**해야 합니다 (예: ID 전송시 자신의 전화번호가 포함되므로 checksum 계산시 포함 여부 유념).
    
- **ID (모뎀번호) 관리**: 전광판마다 고유 ID(전화번호)를 메모리에 저장해 두고, **최초 접속시 0x10 패킷**에 넣어 보내야 합니다. 신프로토콜인 경우 이후 보낼 모든 패킷의 ID 필드에도 동일한 ID를 넣습니다. 만약 여러 전광판이 동일 서버로 접속하는 환경이라면, **각 전광판이 자신의 ID로 오는 패킷만 처리**하도록 구현되어야 합니다. (신프로토콜에서는 서버→전광판 패킷에도 ID가 실릴 가능성이 있어, 자신의 ID가 아닌 패킷은 무시하도록 설계할 수 있습니다).
    
- **시리얼/이더넷 포트 설정**: 전광판 컨트롤러가 직접 서버와 통신하는 경우, **TCP/IP 소켓 클라이언트** 기능이 필요하며, 이더넷 모듈이 없다면 별도 장착해야 합니다. 기존 RS-232 직렬로 서버 연결을 한다면, 프로토콜에 맞춰 0x02/STX등 **제어문자를 그대로 전송**할 수 있는 바이너리 모드로 동작해야 하며 시리얼 통신 파라미터(baudrate 등)는 사전에 서버와 일치시켜야 합니다. (행안부 표준에는 통신속도 등이 명시되었을 수 있으니 확인 필요).
    
- **명령어 지원 범위**: 구현 시 **어떤 명령까지 지원할지** 결정해야 합니다. 최소한 ID 전송(0x10), 문구/멀티메시지 전송(구 0x01 또는 신 0x11 등), 시간동기화(0x03), 전체삭제(구0x04/신0x14)는 지원해야 할 것입니다 ([재해문자전광판 프로토콜 정의서.pdf](file://file-bkkbmpttzmn1cyhcthmxt9%23:~:text=8/)). 추가로 신프로토콜의 밝기/전원제어 관련 명령(예: 0xD1 야간밝기 설정 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=10,%20-l862n0190az4qa092d/)) ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=%20%20%201byte%205,20,%20%20%20-2322wnh752cdjzf03fjt8dzsvc7a7250j0hbpz2wcre598aho1l/)))이나 전광판 상태 보고 명령(온도/습도 등)까지 구현할지 검토해야 합니다. 다빛 전광판 HW가 해당 기능/센서를 지원하면 이를 프로토콜에 맞춰 송수신하도록 합니다.
    
- **메시지 저장/표출 로직**: MOIS 프로토콜은 **여러 개의 메시지 슬롯(최대 100개)**을 관리하는 것을 가정합니다. 전광판 펌웨어도 이를 반영하여, **메모리에 다중 메시지를 저장하고 우선순위에 따라 표시**하는 로직이 필요합니다. 예를 들어 **긴급메시지(방번호 1~~5)**는 항상 최우선으로 즉시 표시하고 다른 일반메시지(6~~100)는 스케줄에 따라 순차 또는 예약 표시하도록 구현할 수 있습니다. 지정된 시작~완료 시간을 활용하여 **현재 시간과 비교해 유효한 메시지만 화면에 표시**해야 합니다. 만약 여러 유효 메시지가 겹치는 경우 우선순위(긴급 여부, 방번호 순 등)에 따라 하나만 표시하거나 교차 표출 전략이 필요합니다. 이러한 **전광판 로컬 스케줄러**를 운용함으로써 중앙 서버 지시를 충실히 이행하게 됩니다.
    
- **텍스트 표시 및 서식**: 구프로토콜 기준으로 메시지 문자열 내 특수코드 '!'를 만나면 다음 문자를 **서식 제어 코드**로 처리한다고 명시되어 있습니다. 예를 들어 `"비상상황!1대피하세요"` 라는 문자열을 수신하면 `!1`을 해석하여 **배경검정/글자적색**으로 색상 설정 후 "대피하세요"를 출력합니다. 이러한 **문자 속성 코드 처리기**를 펌웨어에 구현해야 합니다. '!' 뒤에 오는 조합에 따라 색상, 폰트, 시간표시 등의 기능을 수행해야 하며, 정의서에 여러 코드가 나와 있습니다 (예: `!Y`=년도를 표시, `!M`=월 표시 등 시간삽입 기능도 존재). 신프로토콜의 신규 전광판에서는 해당 기능코드를 **구식 전광판 호환용으로만 지원하거나 무시**할 수 있습니다 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=,%20%20%20%20-6mc76484uie2b73en94gchfpu3fx43by8ay18dzi2c4godld8yl143kjz5amg2c6yepir55f/)) ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=3,%20%20%20%20-yl41qll7a9k8ct4cfv4b2m0ckr4g9c9c0rhevaf261b/)). 다빛솔루션 전광판이 신형 모델이라면, MOIS 신프로토콜에 맞춰 **문자열 내 서식코드를 사용하지 않고** 별도의 효과/색상 필드만 처리하도록 할 수도 있습니다. (예: 3색 LED 전광판에서는 텍스트를 단색으로 출력하거나 서버측에서 이미지를 내려보내기 때문에 '!'코드 미사용 등)
    
- **메모리 및 안정성**: 수신한 대용량 데이터(예: BMP 이미지 수백 KB)를 저장할 버퍼가 컨트롤러에 충분한지 고려합니다. 또한 부분적으로 받은 패킷을 조합하거나, 잘못된 순서로 도착했을 경우 재전송을 요청하는 등 **프로토콜 시나리오상의 예외 처리**를 구현해야 합니다. (예: 2단계 전송 중 예상한 0x12 요청이 없으면 타임아웃 처리 등)
    
- **테스트 및 검증**: 각각의 명령 시나리오에 대해 **프로토콜 분석기** 등을 활용하여 패킷 입출력을 검증합니다. 예를 들어 서버로부터 시간동기화 명령(0x03)이 왔을 때 전광판이 정확히 현재 시간을 세팅하는지, 전체삭제(0x14) 명령 시 모든 표시가 지워지는지 확인합니다. 또한 의도적으로 잘못된 체크섬 패킷을 보내봤을 때 무시하는지, 최대 길이(900바이트) 메시지를 보내도 처리되는지 등 **에러 처리 동작**을 시험합니다.
    

요약하면, 직접 전송 방식은 **전광판 자체가 MOIS 프로토콜의 클라이언트 역할**을 수행하도록 만드는 것입니다. 이는 **초기 개발 부담은 높지만**, 일단 구현되면 **중간 변환 없이 곧바로 중앙 시스템과 통신**하므로 효율적입니다. 다음으로, MOIS 프로토콜을 파싱하여 기존 전광판 명령으로 **변환 중계**하는 방식의 특징을 살펴보겠습니다.

## 방식 2: MOIS 프로토콜 파싱 및 ASCII 변환 중계

### 구현 개요 및 요구사항

**프로토콜 변환 중계 방식**은 전광판 단말 자체는 기존 **다빛솔루션 ASCII 프로토콜**을 그대로 사용하고, 별도의 **중계 소프트웨어/장치**가 MOIS 서버와 통신하여 받은 데이터를 해석한 뒤 전광판에 맞는 명령으로 재전송하는 방법입니다. 이를 통해 **기존 전광판 펌웨어 수정 없이**도 MOIS 시스템 연동이 가능합니다. 요구 환경은 다음과 같습니다:

- **중계기 역할 장치**: PC 서버, 임베디드 컨트롤러(Raspberry Pi 등) 또는 전광판 제어 PC 등에 **MOIS 프로토콜 클라이언트 소프트웨어**를 구현합니다. 이 소프트웨어는 MOIS 서버(IP/포트)에 접속하여 **전광판을 가장한 통신**을 수행합니다. 즉, MOIS 패킷을 수신하고 응답도 하며, 내부적으로 전광판에 명령을 전달합니다.
    
- **전광판과의 통신**: 중계 소프트웨어는 **다빛 전광판의 ASCII 명령어 프로토콜**로 전광판과 통신합니다. 이는 보통 RS-232 직렬이나 전용 이더넷 프로토콜로 ASCII 텍스트 기반 명령을 보내는 방식일 것입니다. 전광판은 이 ASCII 명령을 기존처럼 처리하여 화면에 표시합니다. 다빛솔루션의 ASCII 프로토콜 포맷은 전광판 모델마다 다를 수 있으나, 일반적으로 `<STX><주소><명령코드><데이터><ETX>` 형태나, 사람이 읽을 수 있는 영문/숫자 조합의 명령 문자열일 수 있습니다. **중계기는 전광판의 프로토콜 사양을 사전에 알아야** 하며, MOIS 데이터 필드를 그에 맞게 매핑해야 합니다.
    
- **실시간/지연**: 중계 방식에서는 MOIS -> 중계기 -> 전광판으로 **두 번 전송**이 일어나는 만큼 약간의 지연이 생길 수 있습니다. 그러나 일반적인 TCP/IP 및 로컬 시리얼 통신 지연은 수백 ms 이내이므로, 재난문자 전송의 실시간성 요구에는 크게 문제없습니다. 다만 중계기가 한 대에서 다수 전광판을 다루는 경우 각 전광판으로 명령 분배 시 **동시성 처리**를 고려해야 합니다. (각 전광판별 별도 스레드나 순차처리 등)
    
- **프로토콜 파싱**: 중계 소프트웨어는 **MOIS 구/신 프로토콜 파싱 엔진**을 내장해야 합니다. 이는 앞서 직접 전송 방식에서 전광판이 가져야 했던 파서와 유사하지만, 이제는 소프트웨어 형태로 PC 상에서 동작하게 됩니다. 수신한 바이너리 패킷들을 분석하여, **의미 있는 고수준의 명령 데이터 구조**(예: “방번호=1, 텍스트=‘대피하세요’, 효과=좌측스크롤, 시작시간=즉시, …”)로 변환합니다. 이후 이를 기반으로 **전광판 ASCII 프로토콜 명령**을 생성합니다.
    
- **양방향 통신**: MOIS 서버는 전광판으로부터의 응답도 기대하므로, 중계기는 **전광판 → MOIS 서버로의 메시지도 처리**해야 합니다. 예를 들어 전광판이 ID 전송(0x10)이나 상태 정보 보고를 해야 한다면, 중계기가 전광판에서 필요한 정보를 읽어와 MOIS 형식의 패킷을 만들어 **서버로 전송**합니다. 현실적으로 중계기는 **전광판의 대리인 역할**을 하므로, MOIS 서버와의 통신 프로토콜을 완벽히 구현해야 한다는 점은 직접 방식과 동일합니다. 차이는 **전광판과 주고받는 쪽**이 MOIS가 아닌 ASCII라는 점 뿐입니다.
    

다음 섹션에서는 MOIS 프로토콜의 주요 필드와 기능들을 다빛 전광판 ASCII 명령으로 변환하는 **매핑 로직**을 항목별로 설명합니다.

### 프로토콜 필드 매핑 로직

MOIS 프로토콜로 수신된 데이터 패킷을 다빛솔루션 전광판에 맞게 변환할 때, **각 필드와 기능을 1:1로 대응**시켜 주어야 합니다. 주요 매핑 항목은 **표시효과**, **시간/일정 포맷**, **문자열 및 속성(색상 등)**, **메시지 메모리 관리** 등이 있습니다. 아래에 항목별로 상세히 설명합니다.

- **표출 효과 (시작/완료 효과)**: MOIS에서 정의된 **시작효과(Start Effect)**와 **완료효과(End Effect)** 코드는 전광판의 효과 연출 기능과 대응됩니다. 다빛 전광판 ASCII 프로토콜에서 동일한 효과 연출을 지원한다면, **동등한 효과 코드/명령으로 변환**해야 합니다. 만약 코드 값 체계가 다르다면 변환 테이블에 따라 매핑합니다. 아래는 MOIS 프로토콜에 명시된 효과 코드들의 예시와, 다빛 전광판에서의 코드 대응을 정리한 표입니다.
    

**표 1. 시작 효과 코드 매핑 예시 (MOIS → 다빛 전광판)**

|시작효과 (연출)|MOIS 코드*|다빛 전광판 코드|
|---|---|---|
|바로 표시 (즉시출력)|0x01 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=%20%200x01%20%20,%200x08%20%20%20display-nb320a5x0gtcbu73os3yb64j1lszs1l4x7bxtnk4sntj9v7oh01duswb/))|동일 (0x01)|
|좌측으로 스크롤|0x02 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=%20%200x01%20%20,%200x08%20%20%20display-nb320a5x0gtcbu73os3yb64j1lszs1l4x7bxtnk4sntj9v7oh01duswb/))|동일 (0x02)|
|위로 스크롤|0x03 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=%20%200x01%20%20,%200x08%20%20%20display-nb320a5x0gtcbu73os3yb64j1lszs1l4x7bxtnk4sntj9v7oh01duswb/))|동일 (0x03)|
|아래로 스크롤|0x04 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=0x02%20%20%200x03%20,display%200x0a%20%20%20change-rx335ana13en69ryh6il7qdsleqpjuylu5mbw8kl60b3kzi/))|동일 (0x04)|
|레이저 효과|0x05 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=0x03%20%20%200x04%20,change%200x0b%20line%20%20change-ci436ao1roa26e5589ezh1b629amzuq95q5k3e/))|동일 (0x05)|
|중심에서 상하로 벌어짐|0x06 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=0x04%20%20%200x05%20,0x0c%20%20,%20%201-ur730ay90f2a071go8g4a85dx73q8m9hizzb8az637awhixa57wlzq9v0s/))|동일 (0x06)|
|상하에서 중심으로 모임|0x07 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=0x06%20%20%20%200x07,0x0d%20%20,%20%202-ur730ari1fj1m0a9211d39wxy4f5kgdw7bnw6b69h5oc419br9igrcft3dmxono2x/))|동일 (0x07)|
|문자 회전 디스플레이|0x08 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=0x06%20%20%20%200x07,0x0d%20%20,%20%202-ur730ari1fj1m0a9211d39wxy4f5kgdw7bnw6b69h5oc419br9igrcft3dmxono2x/))|동일 또는 유사 효과 코드|
|라인 회전 디스플레이|0x09 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=0x08%20%20%20display%200x09,change%200x0b%20line%20%20change-9b779au241a3tjagb38303ahba/))|(지원 시 매핑)|
|문자 회전 체인지|0x0A ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=0x08%20%20%20display%200x09,change%200x0b%20line%20%20change-9b779au241a3tjagb38303ahba/))|(지원 시 매핑)|
|라인 회전 체인지|0x0B ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=0x08%20%20%20display%200x09,change%200x0b%20line%20%20change-9b779au241a3tjagb38303ahba/))|(지원 시 매핑)|
|문자 상하 이동1|0x0C (정의서 언급)|(지원 시 매핑)|
|문자 상하 이동2|0x0D (정의서 언급)|(지원 시 매핑)|
|역상 큰글자 느리게|0x0E ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=0x0c%20%20,%20%201,-3n99rs44j571bv0jg6qfh0a6f0c0u7fxeyayqg81b/))|(지원 시 매핑)|
|역상 큰글자 빠르게|0x0F ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=0x0e%20%20%20%20,%200x11%20%20%20-mv91yy60fera761l524gga212eq17ao2dba9903ds7b7utk5pbo7ebmxfbjar54afi6fca/))|(지원 시 매핑)|
|현재시간 표시|0x10 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=0x0e%20%20%20%20,%200x11%20%20%20-mv91yy60fera761l524gga212eq17ao2dba9903ds7b7utk5pbo7ebmxfbjar54afi6fca/))|(별도 처리, 아래 참고)|
|모두 왼쪽으로 스크롤|0x11 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=0x0e%20%20%20%20,%200x11%20%20%20-mv91yy60fera761l524gga212eq17ao2dba9903ds7b7utk5pbo7ebmxfbjar54afi6fca/))|(지원 시 매핑)|

*MOIS 정의서 기준 코드값. 다빛 전광판에서 동일 코드 체계를 사용하는 경우 변환 없이 적용.

**표 2. 완료 효과 코드 매핑 예시 (MOIS → 다빛 전광판)**

|완료효과 (연출)|MOIS 코드*|다빛 전광판 코드|
|---|---|---|
|바로 사라짐 (즉시 소거)|0x05 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=%20%200x05%20%20,%20%200x08%20%20-1j56xd92fkvybea921otx1bljal74cxwq9ja7624aha2689jtbqabgjva8651bka9518j2o8e56saiue/))|동일 (0x05)|
|좌측으로 스크롤되어 사라짐|0x07 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=%20%200x05%20%20,%20%200x08%20%20-1j56xd92fkvybea921otx1bljal74cxwq9ja7624aha2689jtbqabgjva8651bka9518j2o8e56saiue/))|동일 (0x07)|
|위로 스크롤되어 사라짐|0x01 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=0x05%20%20%200x07%20,%20%200x08%20%20-1j020aoa765ooa5763bxjat76chlrxka3745asa6627lkbg88kva264jmk3axa1794hqi9gy0taw0e/))|**0x01** (문맥에 따라 소거 시 0x01을 종료효과로 해석)|
|아래로 스크롤되어 사라짐|0x02 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=0x07%20%20%200x01%20,%200x09%20%20%20-xc94z91vro4dxoonal74dm48ks12a4l5fd4hrv8arp8ehdgsnfuow4pl6a4851a614gi90bd32h/))|**0x02** (동상)|
|중심에서 상하로 벌어지며 사라짐|0x03 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=0x01%20%20%200x02%20,%200x0a%20%20%20-xp66zh71era777oza93d176k334hua036gexjgxyzvfco0i4eemx6c0lo0a4181gmmwc/))|**0x03**|
|상하에서 중심으로 모이며 사라짐|0x04 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=0x02%20%20%20%200x03,%200x0b%20%20%20-xc94z91v8n4dsa32tvv1awa85dz00l1p7hva03p96o7x0b3m3cgumt6qc5lk64aev0a2a7915nkc7e/))|**0x04**|
|문자 회전하며 사라짐|0x06 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=0x04%20%20%20%200x06,%20%200x08%20%20-ou97zsp5c0iofx2btjal8lw3o0jsmw4gmpbv1oq97bpf7crbc343c4ug6slva853wghq894x0a728v33e/))|**0x06**|
|화면 반전 후 소거|0x08 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=0x04%20%20%20%200x06,%200x0a%20%20%20-xp66z1rqgw2cra300pxa0705burdjw1oua18oh4o9a671gji6a0a2619dyeci95c2a7016b3a128p0a4067gx1ti/))|**0x08**|
|좌우로 확대되며 사라짐|0x09 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=0x06%20%20%200x08%20,%200x0a%20%20%20-xp66z561elar620ppv3b1jara445nol3inau669gz6j9i6ao95f5jgiwllxzzfqoa0a4765git8hruuab7e/))|**0x09**|
|중심으로 축소되며 사라짐|0x0A ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=0x08%20%20%200x09%20,%200x0b%20%20%20-xc94z91v8n4dsa310pma9305b6a4636awl5fva03p96od49i9kooa699jvistylpa7022a2a45052abea/))|**0x0A**|
|좌우 역상 확대되며 사라짐|0x0B ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=0x08%20%20%200x09%20,%200x0b%20%20%20-xc94z91v8n4dsa310pma9305b6a4636awl5fva03p96od49i9kooa699jvistylpa7022a2a45052abea/))|**0x0B**|

*완료효과 코드는 시작효과 코드와 겹치지만 “완료효과” 필드 문맥에서 사용될 때 위 의미로 해석됨 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=%20%200x05%20%20,%20%200x08%20%20-1j56xd92fkvybea921otx1bljal74cxwq9ja7624aha2689jtbqabgjva8651bka9518j2o8e56saiue/)). 전광판도 필드 위치에 따라 동일 코드라도 시작/완료를 구분하여 처리해야 함.

위 표에서 알 수 있듯, **대부분의 효과 코드는 MOIS 프로토콜과 전광판 내부 코드가 1:1로 일치**할 가능성이 높습니다. 실제 행안부 정의서에서도 신프로토콜의 효과코드에 대해 “구프로토콜 참조”라고 명시하여 같은 코드 체계를 따르고 있습니다 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=%201byte%201%20hex%201,1byte%202%20hex%20%20-xp311a913v1qrcpxg1r4z2srcmoycov1b0q2dndxa/)) ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=%201byte%202%20hex%20,-y221t9qh9v7qsozfz13cmf8bb83b3g6ajo3byvjlk3a/)). 그러므로 다빛 전광판이 기존에 자체적으로 정의한 효과 코드가 MOIS 표준과 동일하다면, **중계 시 별다른 변환 없이 그대로 전달**하면 됩니다.

만약 전광판 ASCII 명령어가 효과를 **명칭이나 ASCII 문자로 지정**하도록 되어 있다면, 매핑 표를 기반으로 MOIS 코드 -> 해당 명령 파라미터로 변환합니다. 예를 들어 다빛 프로토콜에서 “효과=02”와 같이 문자열 "02"로 보내야 한다면, MOIS 코드 0x02 (좌측스크롤)을 받아 중계기가 ASCII 문자열 "02"로 변환하여 전송합니다.

특이하게 **현재시간 표시(0x10)**와 같은 효과는 전광판에서 별도 처리를 필요로 할 수 있습니다. MOIS에서는 이를 시작효과 코드 중 하나로 넣었지만, 실제로는 **메시지 대신 현재 시각을 표시하는 기능**으로 추정됩니다. 다빛 전광판에 이 기능이 없다면 해당 코드는 무시하거나 기본 효과로 대체할 수 있고, 혹 구현한다면 **전광판의 실시간 시계 데이터**를 이용해 표시하도록 펌웨어 업데이트가 필요합니다. (중계기 단계에서는 해당 코드를 감지하여 전광판에 현재 시간을 넣은 메시지 명령을 생성하는 등의 우회가 가능하나 구현 난도가 높습니다)

- **표출 속도**: MOIS 구프로토콜은 효과속도를 0x01~~0x08 단계로 정의했고, 신프로토콜에서는 이를 **절대 시간(초)**으로 일부 변경했습니다 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=%201byte%202%20hex%20,-y221t9qh9v7qsozfz13cmf8bb83b3g6ajo3byvjlk3a/)) ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=%201byte%203%20hex%201,1byte%204%20hex%201%20-r4141a9o5kjopc46zicya975f4exfjl8fwfvb/)). 다빛 전광판이 효과속도를 지원한다면, 어떤 방식인지 확인해야 합니다. 만약 동일하게 1~~8 단계라면 MOIS 구프로토콜 값을 그대로 쓰면 되고, 1~~6초 등 절대시간 방식이면 중계기가 값을 변환하거나 범위를 제한해야 합니다. 예를 들어 MOIS에서 0x08(가장 느림)을 보내왔는데 전광판이 1~~5 단계만 지원하면, 중계기는 0x08을 0x05로 바꾸는 등의 **보정 로직**을 둘 수 있습니다. 속도 정보가 굳이 필요없는 전광판이라면 해당 필드는 무시하거나 고정값으로 전송하면 됩니다.
    
- **대기 시간**: 효과 완료 후 화면 정지 시간(`Delay` 필드)은 초 단위이므로 그대로 사용할 수 있습니다. 전광판 ASCII 명령에 이 필드가 없다면, 중계기는 해당 시간만큼 **쓰레드 지연 후 다음 동작**하는 방식으로 대체할 수도 있지만, 일반적으로 전광판이 자체 스케줄링 하므로 이 필드는 넘기지 않아도 무방합니다.
    
- **시간 동기화**: MOIS 서버는 일정 간격으로 **시간 전송(0x03)** 명령을 보내 전광판 시계를 맞춥니다. 중계기는 이를 수신하면 전광판 ASCII 프로토콜의 **시간설정 명령**으로 변환해 보내야 합니다. 다빛 전광판에 현재시간을 설정하는 명령이 예를 들어 `TIMESTAMP=YYYYMMDDhhmmss` 형식이라면, MOIS 0x03 패킷의 Data(연,월,일,시,분,초 6바이트일 가능성 높음)를 파싱해 해당 형식으로 전송합니다. 제대로 변환되면 전광판은 자체 RTC를 갱신하고, 서버에는 중계기가 **0x03 응답 패킷**(아마도 같은 0x03으로 응답, 데이터없음)을 보내 동기화 완료를 알립니다.
    
- **메시지 텍스트 및 특성(서식) 변환**: 메시지 본문 텍스트는 **완성형 한글 2바이트** 체계로 전송되므로, 중계기는 이를 **동일한 인코딩으로 전광판에 보내거나**, 전광판이 UTF-8 등의 다른 인코딩을 쓴다면 변환해야 합니다. 다행히 완성형 코드계는 대부분 LED 전광판에서 표준처럼 쓰여, 호환 가능성이 높습니다. 중요한 것은, 구프로토콜 기반 구식 전광판의 경우 텍스트 내에 **서식 제어 시퀀스**가 포함될 수 있다는 점입니다. 예를 들어 `!1`은 빨간색 문자 표시, `!3`은 주황색 배경 등으로 색상을 지정하는 코드이고, `!u`는 밑줄 토글, `!T`는 현재시각 삽입 등 다양한 기능이 정의되어 있습니다.
    

만약 MOIS **구프로토콜** 메시지가 중계기로 들어오면 이미 텍스트 내에 이러한 코드가 포함되어 있을 수 있으므로, **변환 없이 그대로 전광판으로 전달**하면 됩니다. 다빛 전광판이 구식 타입이라면 동일한 `!`코드 체계를 인식하여 적절히 색상/특수표시를 할 것입니다.

반면 MOIS **신프로토콜**은 기본적으로 이러한 임베디드 코드를 사용하지 않는 방향으로 개선되었으며 (신형 3색 전광판은 주로 BMP이미지로 다중색상을 구현하거나 단일 기본색을 사용), 정의서에도 `'!+코드'는 구식 전광판에서만 지원됨`이라고 명시되어 있습니다 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=,%20%20%20%20-6mc76484uie2b73en94gchfpu3fx43by8ay18dzi2c4godld8yl143kjz5amg2c6yepir55f/)). 따라서 **신프로토콜 환경에서는 텍스트 내 서식코드가 아예 안 올 수 있고**, 대신 멀티메시지 종류=0 (BMP)로 컬러 구현을 합니다. 이 경우 중계기는 **컬러 이미지 데이터를 전광판에 표현**해야 하는 도전이 생깁니다. 예를 들어 서버가 3색 BMP 이미지를 0x11/0x13으로 보내오면, 중계기는 해당 BMP를 수신하여 다빛 전광판에 뿌려야 합니다. 전광판 ASCII 프로토콜에 **그래픽 표시 기능**이 있다면 (예: 특정 명령으로 픽셀 버퍼 전송), BMP 데이터를 변환하여 그 명령으로 보내고, 없다면 **지원 불가**로 간주하고 서버에 완료 응답만 보내거나 무시해야 합니다. 이런 미디어 콘텐츠 처리는 복잡하므로, 중계 운용 시 **신규 전광판(컬러)**보다 **텍스트 위주 구형 전광판** 연동에 집중할 가능성이 높습니다.

요약하면, **텍스트 메시지**의 경우 중계기는 문자열을 그대로 전달하되, 전광판 프로토콜 양식에 맞춰 앞뒤 제어문자나 길이 등을 추가하면 됩니다. 그리고 **문자 특성 코드**(`!`)는 양쪽 프로토콜이 동일하게 이해할 수 있으므로 특별한 매핑변환은 필요 없고, **필요시 중계기가 수동으로 추가/변경**할 수는 있습니다. 예를 들어, MOIS 신프로토콜에서 긴급메시지임을 별도 필드로 알려주었다면 (방번호 1~5 사용 등으로 판단) 중계기는 전광판에 전달할 텍스트 앞에 자동으로 `!1` (적색 글씨) 같은 코드를 붙여 **시인성을 높이는 연출**을 할 수 있습니다. 이런 처리는 필수는 아니지만 현장에서 유용할 수 있는 부가 기능입니다.

- **메시지 메모리 관리**: 중계기는 MOIS 서버로부터 여러 **방번호**에 대한 메시지를 수신할 수 있습니다. 이를 전광판에 보내는 전략은 전광판 성능과 기능에 따라 다릅니다:
    
    - 전광판이 자체적으로 **여러 메시지 저장 및 스케줄링**을 지원한다면, **MOIS 방번호를 전광판의 메시지 인덱스**로 사용하면 됩니다. 예를 들어 MOIS에서 2번 방에 저장하라고 온 메시지를 전광판에도 2번 메모리 위치에 저장하는 명령을 보냅니다. (일부 전광판은 메모리를 구획화하여 번호별 저장/삭제 명령을 갖추고 있습니다. 없다면, 메시지 ID를 파일명처럼 간주해 관리하는 식으로 에뮬레이션할 수 있습니다.)
        
    - 전광판이 **한 번에 한 메시지만 표시**할 수 있고 별도 저장영역이 없다면, 중계기는 MOIS로부터 새 메시지가 올 때마다 즉시 기존 것을 지우고 새 메시지를 표시하는 식으로 동작해야 합니다. 즉 **실시간 중계** 개념으로 움직이고, 방번호나 긴급/일반 여부를 스케줄에 크게 반영하지 못할 수 있습니다. 다만 이런 경우 긴급메시지(1~~5번)는 항상 덮어쓰면서 표시, 일반메시지(6~~100번)는 긴급이 없을 때만 교체 표시하는 등 중계기 수준에서라도 규칙을 적용할 수 있습니다.
        
    - MOIS 서버로부터 **방정보 요구(구 0x02)** 혹은 **전송 확인(신 0x13)** 등의 응답이 올 때, 중계기는 현재 전광판에 저장된(또는 표시 중인) 메시지 정보를 참조해 **적절히 응답**해야 합니다. 예를 들어 구프로토콜에서 서버가 “방정보 요구(0x02)”를 보내면, 전광판은 직전에 받은 문구 전송의 내용을 그대로 되돌려주는 것으로 정의되어 있습니다. 중계기는 이를 감지하면 **해당 방번호의 현재 메시지 내용을 추적**하고 있다가, 동일한 0x01 문구 전송 데이터 패킷을 서버로 보내주어야 합니다. 이를 위해 중계기는 **메시지 이력/상태를 캐싱**해야 합니다. 신프로토콜의 전송 확인(0x13)은 전광판이 데이터 수신 완료를 알리는 것이므로, 중계기는 전광판에 명령 전송이 성공했다면 즉시 0x13 ACK를 서버로 보내 완료를 알려줍니다 (전광판이 따로 ACK를 주지 않아도, 중계 소프트웨어에서 성공 여부를 판단하여 보냄).
        
- **기타 기능**: MOIS 프로토콜에는 **야간 모드 설정(0xD1)**, **전광판 상태 보고(예: 온도/문 개폐 등)**와 같은 부가 명령도 존재합니다 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=10,%20-l862n0190az4qa092d/)) ([재해문자전광판 프로토콜 정의서.pdf](file://file-bkkbmpttzmn1cyhcthmxt9%23:~:text=fan%20&%20heater%201byte%205,off\)%20smps:%208%2F7%2F6%2F5%2F4%2F3%2F2%2F1/)). 중계기 구현 시 해당 기능들이 꼭 필요하지 않다면 서버의 해당 명령을 수신해도 **무시 혹은 기본 ACK만 전송**하도록 할 수 있습니다. 하지만 가능하면 구현하는 것이 좋습니다. 예를 들어 0xD1 명령 (시작시간/완료시간 및 주간/야간 밝기 설정)을 수신하면, 다빛 전광판의 **밝기 조절 명령**으로 변환하여 (예: `BRIGHT=12` 등) 보내고 바로 ACK를 돌려줍니다 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=%20%20%201byte%205,20,%20%20%20-2322wnh752cdjzf03fjt8dzsvc7a7250j0hbpz2wcre598aho1l/)) ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=on%201byte%207%20hex%20,1byte%208%20hex%20-2l710afz88a6widwa/)). 전광판의 현재 **온도/습도/휘도/도어 상태** 등을 요청하는 명령이 있을 경우 (정의서 일부에 이러한 필드가 나와 있음 ([재해문자전광판 프로토콜 정의서.pdf](file://file-bkkbmpttzmn1cyhcthmxt9%23:~:text=fan%20&%20heater%201byte%205,off\)%20smps:%208%2F7%2F6%2F5%2F4%2F3%2F2%2F1/)) ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=%201byte%207%20hex%20,1023%20\(0%20%20-q573yv69mtd0f801gudtal2c6tf/))), 전광판에 센서가 있다면 ASCII 프로토콜로 상태요청을 보내 값을 읽고, MOIS 형식의 상태 응답 패킷을 조립해 서버에 전송합니다. 이처럼 **중계기는 필요한 장치 I/O 제어를 수행**하여 MOIS 요구에 대응해야 합니다.
    

정리하면, 프로토콜 변환 중계 방식에서는 **MOIS 패킷 ↔ 전광판 명령** 간의 철저한 매핑이 핵심입니다. 다행히 **문구 전송, 효과, 일정, 색상 등의 개념은 양쪽에 모두 존재**하므로, 적절한 변환 규칙을 마련하면 구현할 수 있습니다. 아래는 **문자 속성(색상 등) 코드**에 대한 매핑 테이블로, 구프로토콜의 경우 전광판에 동일하게 적용할 수 있습니다:

**표 3. 문자 색상/속성 코드 (구프로토콜 ‘!’ 시퀀스) 매핑**

|코드 (텍스트 내)|MOIS 정의서 의미|다빛 전광판 처리 방식|
|---|---|---|
|`!0`|배경 **검정**, 문자 **주황**|동일 - 배경/문자색 설정|
|`!1`|배경 **검정**, 문자 **적색**|동일|
|`!2`|배경 **검정**, 문자 **녹색**|동일|
|`!3`|배경 **주황**, 문자 **검정**|동일|
|`!4`|배경 **적색**, 문자 **녹색**|동일 (적색+녹색=황색 문자)|
|`!5`|배경 **녹색**, 문자 **적색**|동일 (배경녹/문자적)|
|`!6`|배경 **적색**, 문자 **검정**|동일|
|`!7`|배경 **녹색**, 문자 **검정**|동일|
|`!8`|배경 **적색**, 문자 **주황**|동일|
|`!Tss`|현재 시간 출력 (12시간제 오전/오후 시:분)|전광판 시계값으로 치환 출력|
|`!Yss`|현재 년도 출력 (“20YY년”)|전광판 시계값으로 치환 출력|
|`!Dss`|현재 월일 출력 (“M월D일”)|전광판 시계값으로 치환 출력|
|`!Wss`|현재 요일 출력 (월요일~일요일)|전광판 시계값으로 치환 출력|
|`!yss`|년도(뒷자리) 출력 (YY)|전광판 시계값으로 치환 출력|
|`!mss`|분 출력 (MM분)|전광판 시계값으로 치환 출력|
|`!u`|밑줄 토글|동일 또는 대응 효과 적용|

_(주: 상기 `!T`, `!Y` 등의 시간코드는 MOIS 프로토콜에 존재하나, 다빛 전광판에서 지원하지 않을 경우 중계기 단계에서 제거하거나 무시해야 함. 일반적으로 구식 전광판에서만 사용됨 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=,%20%20%20%20-6mc76484uie2b73en94gchfpu3fx43by8ay18dzi2c4godld8yl143kjz5amg2c6yepir55f/)).)_

위 표에서 보듯 색상 조합 코드는 3색(적,녹,주황) 전광판의 한계를 반영하여 **9가지 프리셋**으로 정해져 있습니다. 다빛솔루션 전광판이 3색 LED라면 동일한 색상 구현이 가능하므로 이 코드를 그대로 해석하면 되고, 만약 **단색(적색 전광판)**이라면 이 코드들은 무시하거나, `!0`~`!2` 모두 “문자 적색”으로 처리하는 식으로 중계기에서 변환할 수 있습니다.

- **사이렌 제어**: MOIS 메시지 필드 중 `싸이렌출력` (T/F)은 중계기가 받아서, 전광판에 **사이렌 활성화 명령**을 내려주어야 합니다. 전광판에 사이렌이나 경광등이 물리적으로 연결되어 있다면, ASCII 프로토콜에 해당 기능 제어 명령이 있을 것입니다. 예를 들어 `ALARM=ON` 등의 명령을 보낼 수 있고, 시간 설정이 가능하면 *“처음 1회 울림”*이라는 MOIS 조건에 따라 **해당 메시지 시작 시점에만 1회** 울리도록 제어해야 합니다. 전광판에 그런 제어가 불가능하면, 중계기가 별도로 GPIO 등을 통해 사이렌 릴레이를 on/off하는 하드웨어적 방법을 고려해야 합니다.
    
- **ACK/응답 처리**: 중계기는 MOIS 서버와 **TCP 세션을 지속**하며, 필요한 응답 패킷을 즉시 보내주어야 합니다. 예를 들어 문구전송(0x01/0x11 등)을 받으면 전광판에 명령 전송 후 **성공 여부에 따라** 서버에 **전송 완료 응답(구프로토콜에선 0x15, 신프로토콜에선 0x13)**을 반환해야 합니다 ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=%201byte%201%20hex%201-yj60vk7f2260c/)) ([재해문자전광판 프로토콜 정의서.pdf](file://file-bkkbmpttzmn1cyhcthmxt9%23:~:text=/)). 만약 전광판 통신에 실패하면 (예: 전광판 응답 없음 등) 중계기는 서버에 실패를 나타내는 특별한 패킷이 정의되어 있지 않다면 응답 자체를 안 보내 타임아웃을 유도하거나, 재전송 요청을 처리해야 합니다. **즉, 중계기는 서버와의 프로토콜상 논리적 일관성을 유지하면서, 내부적으로 전광판 제어의 신뢰성을 관리**해야 합니다.
    

### 변환 중계 예시 및 구현상의 유의점

앞서 개괄한 매핑 로직을 실제 시나리오로 예를 들면 다음과 같습니다:

> **예시 시나리오**: MOIS **구프로토콜**로 긴급메시지(방번호=1, “화재 발생! 대피 바랍니다.”, 효과=바로표시, 빨간 글씨)에 대한 패킷을 중계기가 수신한 경우.  
> – MOIS 서버 → 중계기 : `[STX(0xAB)] [LENGTH=...] [CMD=0x01] [Data="방1,효과코드0x01,속도0x01,대피 바랍니다...!1대피..."] [CHECKSUM] [ETX]` (Hex로 인코딩된 실제 바이트들)  
> – 중계기 동작: 패킷 파싱 → 구조체화: `{방번호:1, 효과:0x01(즉시), 속도:0x01(가장빠름), 색상코드:'!1'(검정배경+적색문자), 텍스트:"화재 발생! 대피 바랍니다." ...}`  
> – **전광판 명령 생성**: 다빛 전광판 ASCII 프로토콜에 따라, 예를 들어 전광판에 메시지 추가 명령이 `"ADDTXT,<방>,<효과>,<속도>,<시작시각>,<종료시각>,<사이렌>,<텍스트>"` 형식이라고 가정하면:  
> `"ADDTXT,1,01,01,000000,999999,T,화재 발생! 대피 바랍니다."` 를 생성 (`!1` 코드 포함 필요시 텍스트에 삽입)  
> – 중계기 → 전광판: 위 ASCII 명령을 시리얼로 전송 (STX/ETX 등 framing은 해당 프로토콜에 맞춰 추가)  
> – 전광판 처리: 명령 파싱 후 1번 슬롯에 메시지 저장/표시, 사이렌 울림  
> – 전광판 → 중계기: (성공시 ACK 응답, 예: `"OK"` 혹은 체크섬 ACK 바이트 등)  
> – 중계기 → MOIS 서버: 성공을 의미하는 **응답 패킷** 전송 (구프로토콜의 경우 0x15 응답, 데이터없음) ([재해문자전광판 프로토콜 정의서.pdf](file://xn--file-bkkbmpttzmn1cyhcthmxt9%23:~:text=%20%20%20%20,-7210qkn2b434a173ckiskp9gou8coa152egqfea692od24keryc/)).

위 흐름에서 볼 수 있듯이, 중계기는 **프로토콜 변환 외에도 전송 흐름 제어**를 수행합니다. 전광판이 명령 수신을 확인하지 못하면 중계기는 MOIS 서버에 응답을 보내지 않고 재시도하거나, 오류 패킷(정의되어 있다면)으로 응답해야 합니다.

또한 실제 구현 시 다음과 같은 **예외/오류 처리**에 유의해야 합니다:

- **통신 오류 처리**: MOIS 서버와의 연결이 끊어지면 재연결 로직이 필요합니다. 전광판과의 시리얼 통신 오류(응답 시간초과 등) 발생 시 해당 명령을 재시도하거나 실패로 간주해야 합니다. 여러 전광판을 한 중계기가 다룬다면, **특정 전광판 연결 실패가 전체 서버 세션에 영향**을 주지 않도록 독립적으로 관리합니다.
    
- **데이터 오류**: 수신 패킷의 체크섬 불일치, LENGTH 불일치 시 그 패킷을 버리고 서버에 NACK를 보낼 방법은 정의되어 있지 않으므로 (프로토콜에 특별 NACK는 없음), **요청에 응답하지 않음**으로써 서버가 재전송하거나 타임아웃 처리하게 유도합니다. 중계기는 내부 로깅을 통해 해당 오류를 추적합니다.
    
- **부분 전송 및 재조립**: 신프로토콜에서는 여러 데이터 패킷(분할전송)으로 나눠서 올 수 있습니다. 중계기는 이를 **모아서 하나의 완전한 콘텐츠**를 구성해야 합니다. 예컨대 BMP 이미지가 3개 패킷으로 왔다면, 모두 수신한 후 전광판에 한 번에 처리합니다. 만약 일부 패킷이 누락되면 전광판에 보내지 않고, 서버로 재요청(0x12 패킷 등)을 중계기가 대신 보내거나, 세션을 재시도해야 합니다.
    
- **메시지 길이 한계**: MOIS는 한 패킷에 최대 900바이트 데이터를 보낼 수 있다고 하지만, 다빛 전광판이 한 번에 처리할 수 있는 텍스트 길이는 제한이 있을 수 있습니다. 예를 들어 전광판 메모리가 100자까지만 지원하면, 그보다 긴 메시지는 **잘라내거나 여러 화면에 나눠 표시**해야 할 수 있습니다. 중계기는 이러한 제약을 고려해 필요하면 수신 메시지를 트렁케이트하거나, 스크롤 효과로 긴 내용을 표현하도록 유도합니다. (긴 문장이 오면 자동으로 좌우 스크롤효과로 설정하는 등의 정책 적용 가능)
    
- **예약 시간대 처리**: 메시지에 시작/종료 시간이 지정되었을 때, 전광판이 자체 시계로 처리 못 한다면, 중계기가 **예약 관리**를 해야 합니다. 예를 들어 “오늘 15시에 표시 시작” 메시지를 14시에 받았다면, 바로 전광판에 보내지 않고 **로컬 버퍼에 보관**했다가 15:00에 해당 명령을 보내는 식입니다. 그리고 “16시에 종료”라면 16:00에 전광판에 해당 메시지를 삭제하거나 화면을 지우는 명령을 보내야 합니다. 이러한 스케줄러 역할은 가능하면 전광판 펌웨어가 하도록 하는 것이 좋지만, 불가능하다면 중계기가 대신 수행합니다.
    
- **동기화 이슈**: MOIS 서버는 전송한 긴급메시지가 제대로 표시되었는지 확인이 어려우므로, 운영상 **2중 체크**를 할 수 있습니다. 중계기는 전광판으로부터 표시 완료나 오류 상태를 받아 서버 관리자에게 피드백을 주는 기능을 넣을 수 있습니다. 예를 들어 전광판이 `"메시지 수신 완료"` 라고 중계기에 신호를 주면 (혹은 중계기가 그냥 전송 성공으로 간주), 이를 모니터링 로그에 남겨 두거나, 웹 대시보드에 상태를 표시하는 식입니다.
    

마지막으로, 두 가지 방식 (직접 vs 중계)에 대한 **효율성과 적합성**을 다빛솔루션 전광판 관점에서 비교해보겠습니다.

## 방식 비교: 효율성 및 선정 기준

두 구현 방안 모두 일장일단이 있으며, **효율적**이라는 의미도 맥락에 따라 다르게 평가될 수 있습니다. 아래 표는 **다빛솔루션 전광판 시스템** 기준에서 각 방식의 특징을 비교한 것입니다:

**표 4. 직접 전송 vs 변환 중계 방식 비교**

|비교 항목|**방식 1: MOIS 프로토콜 직접 전송**|**방식 2: 프로토콜 변환 중계**|
|---|---|---|
|**펌웨어/소프트웨어 변경**|전광판 **펌웨어 수정** 필요 (MOIS 프로토콜 처리 로직 임베디드). 기존 ASCII 프로토콜과 이중 구현 가능.|**중계 소프트웨어 개발** 필요 (PC/임베디드). 전광판 펌웨어 **무변경**.|
|**개발 복잡도**|임베디드 환경에서 **TCP/IP 스택 + 프로토콜 처리** 구현 필요 – 상대적으로 **고난도**, 디버깅 어려움.|고성능 PC/장치에서 구현 – **풍부한 라이브러리 활용** 가능, 디버깅 용이. (패킷 캡처 등)|
|**유지보수성**|각 전광판 개별 펌웨어 업데이트 필요. MOIS 프로토콜 개정 시 **다수 장비 수정** 요구.|중계 소프트웨어만 수정하면 됨. **중앙에서 일괄 업데이트** 용이.|
|**실시간성**|**단일 단계 전송** – 지연 최소화. (전광판↔서버 직접)|**2단계 전송** – 약간 지연 증가 (중계 단계 추가), 그러나 수백 ms 수준 미미.|
|**신뢰성**|전광판이 직접 서버와 통신하므로 **중간 장애 포인트 적음**. 다만 임베디드 네트워크 불안정성 고려.|중계기 추가로 **고장 지점 증가** (중계 PC 다운 시 통신두절). 대신 전광판 현장문제와 서버문제를 **분리**하여 트러블슈팅 가능.|
|**기능 지원 범위**|전광판 HW 한계 내에서만 기능 구현. (예: BMP 다운로드 등은 전광판이 직접 해야 함) **고급 기능 구현 어려울 수 있음**.|중계기가 비교적 **고사양**이라 복잡한 처리 가능. (예: BMP를 전광판 포맷 변환) 하지만 전광판 자체가 지원 못하는 기능은 여전히 제한.|
|**다중 전광판 관리**|각각의 전광판이 **별도 서버 세션** 유지. 중앙 서버에서 다수 연결 관리.|중계기가 **여러 전광판을 통합** 관리 가능 (1세션로 여러 대 제어 가능하게 꾸밀 수 있음).|
|**현장 설치 및 비용**|전광판에 **네트워크 모듈/모뎀** 장착 및 설정 필요. (개당 통신모듈 비용)|전광판은 기존 상태 유지, **중계 서버/장치 설치**. (지역별로 PC 한 대 등)|
|**확장성**|전광판에 새로운 프로토콜 추가하려면 **메모리/코드 용량 제약**. 대형 업데이트 어려움.|중계 소프트웨어는 PC자원 이용, **업데이트나 타 프로토콜 추가 용이** (예: 다른 브랜드 전광판도 하나의 중계서버로 통합 가능).|
|**실시간 모니터링**|중앙서버 이외에 전광판 상태를 볼 방법 제한. (임베디드 로그 수집 어려움)|중계기에서 **로그 수집 및 UI 모니터링** 구현 가능 – 운용 효율 향상.|

**판단 기준 및 권장사항**: 다빛솔루션 전광판 시스템이 **신규 제작 모델**이고 향후 행안부 신프로토콜을 **표준 기능으로 채택**하려는 경우, **직접 전송 방식(신프로토콜 직접 구현)**이 바람직합니다. 이는 **서버와의 통신이 단순화**되고, 중간 링크 없이 바로 연동되므로 장기적으로 유지보수가 수월해집니다. 특히 신규 모델은 프로세서 성능이 높아 IP 스택과 프로토콜을 충분히 소화할 수 있고, **출하 시 표준호환 제품**으로 홍보할 수 있습니다.

반면, **기존에 납품된 전광판들이 많거나** 한정된 환경에서 동작하는 구형 전광판의 경우, 펌웨어 업그레이드가 번거롭고 위험할 수 있습니다. 이때는 **프로토콜 변환 중계 방식**이 효율적입니다. 새로운 MOIS 시스템에 맞춰 **중계 서버만 세팅하면** 기존 전광판도 업그레이드 없이 재난문자 수신이 가능합니다. 개발 측면에서도 PC 기반 소프트웨어로 구현하므로 **개발 생산성**이 높고, 문제 발생 시 원격 패치도 쉬워집니다.

또한 **운영 환경**도 고려해야 합니다. 예를 들어 각 전광판에 개별 통신 모듈(예: LTE 모뎀)을 넣어 중앙에 직접 접속시키는 것은 통신비나 관리 측면에서 부담일 수 있습니다. 대신, 한 지역의 전광판 여러 대를 **로컬 중계서버** 한 대가 관리한다면, 중앙과의 채널은 하나로 묶이고 **현장 LAN으로 전광판을 제어**하므로 경제적입니다.

정리하면, **다빛솔루션 전광판 기준 효율성 판단**은 다음과 같습니다:

- **직접 전송**이 효율적: 전광판 기종이 최신이며 MOIS 프로토콜 전부를 내장 구현 가능하고, 장비 대수가 많지 않아 **개별 관리가 가능**한 경우. 특히 **신규 프로젝트**로 처음부터 설계한다면 권장.
    
- **변환 중계**가 효율적: 이미 설치된 구형 전광판을 **신규 MOIS 시스템에 빠르게 대응**해야 하는 경우, 또는 전광판이 **프로토콜의 일부 기능(예: 영상표출)을 지원 못 하는 경우**. 이 방식은 **유연성과 개발속도** 면에서 유리하며, 향후 다른 시스템과의 연계 요구에도 중앙 소프트웨어 수정으로 대응하기 쉽습니다.
    

마지막으로, 선택에 상관없이 **充분한 테스트**와 **협의**가 중요합니다. 특히 재난문자 시스템은 공공 안전과 직결되므로, 어떤 방식이든 **오류 발생 가능성을 최소화**하고 이중의 대비책(예: 중계 실패 시 수동 전환 등)을 마련하는 것이 좋습니다. 다빛솔루션 전광판이 해당 프로토콜을 안정적으로 지원함으로써, 재난 시 국민들에게 정확한 정보를 전달하는 데 기여할 수 있기를 기대합니다.