아래는 이전 문서에 **JSON 코드별 세부 설명**을 보강한 최종 버전입니다. 각 예제 JSON에 대해 **필드별 의미**를 조금 더 자세히 풀이했습니다. 필요한 부분을 참고하시면 좋겠습니다.

---

# **전송/응답 JSON 프로토콜 개요**
## **1. 메시지 구조 요약**
MQTT를 통해 전광판(Device)과 TCS(신호제어) 간 통신 시, **JSON 형식**의 메시지를 주고받습니다. 다음은 공통적으로 사용하는 필드들에 대한 개요입니다.

|키|예시값|설명|
|:--|:--|:--|
|`MSG_TYPE`|`"GET"`, `"SET"`, `"TEXT"`, `"IMAGE"`, `"FEEDBACK"` 등|메시지 유형 - **GET**: 장치 상태 조회- **SET**: 장치 설정 변경- **IMAGE**: 이미지파일 전송- **TEXT**: 텍스트(문구) 설정- **FEEDBACK**: 디바이스에서 발생한 이벤트/알림|
|`MSG_VER`|`20241028`|메시지 버전(예: YYYYMMDD 형식)|
|`MSG_ID`|`1730011015000`|메시지 고유 식별자 (요청-응답 매칭 시 사용). 요청과 응답이 동일한 `MSG_ID`를 가짐|
|`MOID`|다양한 타입(`Object`, `Array`, `String` 등)|관리할 대상(Object) 식별자(ID), 혹은 여러 키의 배열/객체. 전광판 내부 항목에 접근하기 위한 “경로”|
|`RESULT_CODE`|`0` / `1` / 기타 숫자|**응답 메시지**에서 사용. 0 또는 1이면 성공, 그 외는 에러 코드(예: 98, 99 등)|
|`RESULT_MSG`|`"OK"`, `"Invalid parameter"` 등|**응답 메시지**에서 사용. `RESULT_CODE`가 에러일 경우 그 사유가 담김|
|`RESULT`|`Object`|**응답 메시지**에서 사용. 각 `MOID`별 결과나 상태 정보가 포함됨|

- **TCS → Device**: 보통 **제어/요청 메시지**를 **Publish** (`igw/tsc/dev` 등).
- **Device → TCS**: 보통 **응답/피드백 메시지**를 **Publish** (`feedback.20` 등).  
    즉, TCS 입장에서는 **Publish**로 **요청**을 보내고, **Subscribe**로 **응답/피드백**을 받는 구조입니다.  
    Device 또한 반대 토픽을 **Subscribe**하고, 필요한 때 **Publish**하여 결과를 보내는 식입니다.

### **1.1. MSG_TYPE 종류**
- **GET**: 장치(전광판)의 상태나 설정 값을 조회.
- **SET**: 장치(전광판)의 설정 값을 변경.
- **IMAGE**: 이미지 파일을 전광판으로 전송.
- **TEXT**: 실시간 문구, 페이지 문구 등 텍스트 표시 설정.
- **FEEDBACK**: 디바이스(전광판)에서 자발적으로 전송하는 이벤트/알림 (예: 에러 발생).

### **1.2. MSG_ID 활용**
- 요청(`GET`, `SET`, `IMAGE`, `TEXT`) 시 `MSG_ID`를 유니크하게 생성.
- 응답(`*_RESPONSE`)에서 동일한 `MSG_ID` 사용 → 요청/응답 매칭 용도.

### **1.3. MOID 구조**
- 예: `"2.RTE058.3.2"` →
    - `"2"`: 전광판 관리 섹션(최상위 키)
    - `"RTE058"`: 특정 전광판 식별자
    - `".3.2"`: 그 하위 키(전광판 구성설정 섹션=3, 그리고 그 안의 밝기설정=2 등)

---

# **전광판 프로토콜 통합 예제 문서**
> **아래부터는** 위 JSON 프로토콜 개요를 바탕으로, 구체적인 예제(요청/응답)들을 정리합니다. 각 예제가 **무엇을 의미**하며, **각 필드가 무엇을 나타내는지**를 중점적으로 설명합니다.

## **목차**
1. 토픽 규칙 및 공통 전제
2. GET 요청/응답 (상태 조회)
3. SET 요청/응답 (전광판 설정 변경)
4. 이벤트 메시지
    - 4.1. 피드백(이벤트) 메시지 예제: 전광판 리셋
    - 4.2. 에러 상황 예제 (SET 요청 시 잘못된 파라미터)
5. 이미지 업로드 및 스케줄 관리
    - 5.1. 공통 필드 설명
    - 5.2. 이미지 업로드 프로토콜
    - 5.3. 이미지 스케줄 프로토콜
    - 5.4. 장점
6. 텍스트 메시지
    - 6.1. 실시간 문구(Real-time Text)
    - 6.2. 페이지 문구(Page Text)
    - 6.3. 페이지 메시지 갯수 설정
---

## **1. 토픽 규칙 및 공통 전제**
- **TCS → Device 제어 요청 토픽**: `igw/tsc/dev`
    - TCS에서 전광판에 명령(GET, SET, IMAGE, TEXT 등)을 보낼 때 사용하는 **Publish** 경로.
- **Device → TCS 응답 및 피드백 토픽**: `feedback.20`
    - 전광판이 응답(`*_RESPONSE`)이나 이벤트(`FEEDBACK`)를 **Publish**하는 경로.
    - `feedback.10` 또는 `feedback.30` 등으로 긴급도나 로그성에 따라 확장 가능.

---

## **2. GET 요청/응답 (상태 조회)**
**시나리오**: TCS가 전광판 시간, 밝기, 화면 구성, 폰트 정보 등을 확인하고자 함.

### **2.1. GET 요청(JSON)**
```json
{
  "MSG_TYPE": "GET",
  "MSG_VER": 20241028,
  "MSG_ID": 1730011015000,
  "MOID": {
    "2.RTE058.2.1": 1,
    "2.RTE058.2.2": 1,
    "2.RTE058.2.3": 1,
    "2.RTE058.2.4": 1,
    "2.RTE058.2.5": 1
  }
}
```

- **`MSG_TYPE`:** `"GET"` → 상태 조회.
- **`MSG_VER`:** `20241028` → 메시지 버전(YYYYMMDD).
- **`MSG_ID`:** `1730011015000` → 요청 식별자. 응답에서 동일하게 사용.
- **`MOID`:** 조회 대상 키 목록.
    - 예: `"2.RTE058.2.1": 1` → 전광판 RTE058의 상태정보 섹션(2) 중 항목(1)을 조회하겠다는 의미.

### **2.2. GET 응답(JSON)**
```json
{
  "MSG_TYPE": "GET_RESPONSE",
  "MSG_VER": 20241028,
  "MSG_ID": 1730011015000,
  "RESULT_CODE": 0,
  "RESULT_MSG": "OK",
  "RESULT": {
    "2.RTE058.2.1": "2306192123456",
    "2.RTE058.2.2": 50,
    "2.RTE058.2.3": [6, 2, 0, 0],
    "2.RTE058.2.4": [
      "ENG 08x16-DABIT.fnt",
      "KOR 16x16-DABIT.fnt",
      "USER 16x16-Special.fnt",
      "ENG 16x16-ASCII-Roman.fnt",
      "KOR_UniCode 16x16.fnt",
      "USER 16x16-Normal.fnt"
    ],
    "2.RTE058.2.5": [
      "V3.0.9",
      240
    ]
  }
}

```

- **`MSG_TYPE`:** `"GET_RESPONSE"` → GET에 대한 응답.
- **`MSG_ID`:** 요청과 동일한 `1730011015000`.
- **`RESULT_CODE`:** `0` → 조회 성공
- **`RESULT_MSG`:** `"OK"` → 성공 메시지.
- **`RESULT`:** 실제 조회된 데이터:
    - `"2.RTE058.2.1": "2306192123456"` (예: 전광판 시간)
    - `"2.RTE058.2.2": 50` (예: 밝기)
    - `"2.RTE058.2.3": [6, 2, 0, 0]` (예: 화면 구성)
    - `"2.RTE058.2.4": [...]` (예: 폰트 파일 목록)
    - `"2.RTE058.2.5": [...]` (예: 펌웨어 버전, CPU 속도 등)

---

## **3. SET 요청/응답 (전광판 설정 변경)**
**시나리오**: 전광판의 화면 모듈 개수(가로/세로)와 밝기(75%)를 설정하고 싶다.

### **3.1. SET 요청(JSON)**

```json
{
  "MSG_TYPE": "SET",
  "MSG_VER": 20241028,
  "MSG_ID": 1730011016000,
  "MOID": {
    "2.RTE058.3.1": "2306192123456",
    "2.RTE058.3.2": 50,
    "2.RTE058.3.3": [6, 2, 0, 0],
    "2.RTE058.3.4": 1,
    "2.RTE058.3.5": 3,
    "2.RTE058.3.6": 1
  }
}
```

- **`MSG_TYPE`:** `"SET"` → 설정 변경.
- **`MSG_VER`:** `20241028`.
- **`MSG_ID`:** `1730011016000`.
- **`MOID`:**
    - `"2.RTE058.3.2": 75` → 전광판 밝기를 75로 설정.
    - `"2.RTE058.3.3": [8, 2, 0, 0]` → 화면 구성(가로=8, 세로=2, 단면=0, 배열=0).

### **3.2. SET 응답(JSON)**

```json
{
  "MSG_TYPE": "SET_RESPONSE",
  "MSG_VER": 20241028,
  "MSG_ID": 1730011016000,
  "RESULT_CODE": 0,
  "RESULT_MSG": "OK",
  "RESULT": {
    "2.RTE058.3.1": 0,
    "2.RTE058.3.2": 0,
    "2.RTE058.3.3": 0,
    "2.RTE058.3.4": 0,
    "2.RTE058.3.5": 0,
    "2.RTE058.3.6": 0
  }
}
```

- **`MSG_TYPE`:** `"SET_RESPONSE"` → SET에 대한 응답.
- **`MSG_ID`:** 요청의 `1730011016000`과 동일.
- **`RESULT_CODE`:** `0` → 성공.
- **`RESULT`:** 각 MOID 처리 결과(0=정상).
    - `"2.RTE058.3.2": 0` (밝기 설정 성공)
    - `"2.RTE058.3.3": 0` (화면 구성 설정 성공)

---

## **4. 이벤트 메시지**
### **4.1. 피드백(이벤트) 메시지 예제: 전광판 리셋**

```json
{
  "MSG_TYPE": "FEEDBACK",
  "MSG_VER": 20241108,
  "MSG_ID": 1730011029000,
  "PRIORITY": 10,
  "MOID": {
    "2.RTE058.1": [1727403729, 1, 1727403729, 1727403729]
  },
  "DESC": "전광판 리셋 완료",
}
```

- **`MSG_TYPE`:** `"FEEDBACK"` → 디바이스 스스로 보내는 이벤트 메시지.
- **`PRIORITY`:** `10` → 우선순위(긴급도) 높음.
- **`MOID`:** `"2.RTE058.1"` → 상태 요약(예: `[전송시간, 상태, 이벤트발생시간, 데이터갱신시간]`).
    - 이 예시에서 `1`은 작동중(정상) 상태를 의미.
- **`DESC`:** `"전광판 리셋 완료"` → 리셋된 상황 설명.


### **4.2. 에러 상황 예제 
**시나리오**: TCS에서 전광판에 `"SET"` 명령을 보냈는데, `MOID` 객체가 비어 있어(설정할 대상이 없음) 디바이스 측에서 에러를 반환하는 상황입니다.

**1) 요청 (TCS → Device)**  
토픽: `igw/tsc/dev`
```json
{
  "MSG_TYPE": "SET",
  "MSG_VER": 20241028,
  "MSG_ID": 1730011028000,
  "MOID": {
    "2.RTE058.3.7": 5
  }
}
```
- **내용 설명**
	- `MSG_TYPE`=`"SET"`: 전광판 설정 변경 요청
	- `MOID`: `"2.RTE058.3.7"` → 실제 전광판에 존재하지 않는 키
	- 이로 인해 디바이스에서 **유효하지 않은 요청**으로 간주, 에러 응답을 반환하게 됨

**2) 응답 (Device → TCS)**  
토픽: `feedback.20`
```json
{
  "MSG_TYPE": "SET_RESPONSE",
  "MSG_VER": 20241028,
  "MSG_ID": 1730011028000,
  "RESULT_CODE": -4,
  "RESULT_MSG": "Empty or missing RESULT data",
  "RESULT": {}
}
```
- **내용 설명**
    - `MSG_TYPE`=`"SET_RESPONSE"`: `SET` 요청에 대한 응답
    - `MSG_ID`=`1730011028000`: 요청과 동일한 식별자로 매칭
    - `RESULT_CODE`=`-4: 사용자 정의 에러 코드(예: “유효하지 않은 MOID 구조” 등)
    - `RESULT_MSG`=`"Empty or missing RESULT data"`: MOID나 설정 데이터가 비어 있음
    - `RESULT`=`{}`: 결과에 포함된 파라미터가 없음 (에러이므로 구체적인 설정 결과도 없음)


---
## **5. 이미지 업로드 및 스케줄 관리**

### **5.1. 공통 필드 설명**

### **5.1.1. 공통 키**

| 키 이름       | 설명                      | 데이터 타입 | 예시 값                            |
| ---------- | ----------------------- | ------ | ------------------------------- |
| `msg_type` | 메시지 유형                  | 문자열    | `IMAGE`, `SCHEDULE`             |
| `msg_ver`  | 프로토콜 버전                 | 숫자     | `20241028`                      |
| `msg_id`   | 메시지 고유 ID (UNIX 밀리초 포맷) | 숫자     | `1730011028000`                 |
| `moid`     | 메시지가 대상 장치를 나타내는 고유 식별자 | 문자열    | `2.RTE058.4`                    |
| `action`   | 수행할 작업                  | 문자열    | `start`, `data`, `set`          |
| `status`   | 작업 상태                   | 문자열    | `success`, `error`              |
| `code`     | 상태 코드 (HTTP 스타일 코드)     | 숫자     | `0, 1, -1 ~ -7`                 |
| `message`  | 설명 메시지                  | 문자열    | `Upload completed successfully` |

### **5.1.2. 공통 데이터 형식**

- `msg_ver`와 `msg_id`는 정수형으로 처리되어 데이터 크기를 줄이고, 통일된 처리 방식 제공.
- `action`은 현재 수행 중인 작업을 나타내며, 동작에 따라 적절히 변경됩니다.


## **5.2. 이미지 업로드 프로토콜**

### **5.2.1. 업로드 요청**

#### **요청 메시지**

```json
{
  "msg_type": "IMAGE",
  "msg_ver": 20241028,
  "msg_id": 1730011028000,
  "moid":  {
	  "2.RTE058.4": {
		  "action": "start",
		  "file_info": {
		    "filename": "example_image.bmp",
		    "file_type": "bmp",
		    "file_size": 123456,
		    "chunk_size": 1500,
		    "total_chunks": 83
      }
    }
  }
}
```

|필드명|설명|
|---|---|
|`filename`|업로드할 파일의 이름|
|`file_type`|파일 유형 (`bmp`, `gif` 등)|
|`file_size`|파일의 전체 크기(바이트 단위)|
|`chunk_size`|각 청크의 크기(바이트 단위)|
|`total_chunks`|전송될 전체 청크 개수|


### **5.2.2. 데이터 전송**

#### **요청 메시지**

```json
{
  "msg_type": "IMAGE",
  "msg_ver": 20241028,
  "msg_id": 1730011028000,
  "moid": {
	  "2.RTE058.4": {
		  "action": "data", 
		  "chunk_info": {
		    "index": 1,
		    "total": 83
		  },
		  "file_data": "Base64_encoded_chunk_data"
	  }
  }
}
```

|필드명|설명|
|---|---|
|`chunk_info`|현재 청크 정보|
|`index`|전송 중인 청크의 인덱스 번호|
|`total`|전체 청크 개수|
|`file_data`|Base64로 인코딩된 이미지 데이터|


### **5.2.3. 업로드 완료**

#### **요청 메시지**

```json
{
  "msg_type": "IMAGE",
  "msg_ver": 20241028,
  "msg_id": 1730011028000,
  "moid": {
	  "2.RTE058.4": {
		  "action": "end",
		  "status": "success",
		  "code": 0,
		  "message": "Upload completed successfully"
	  }
  }
}
```


### **5.2.4. 공통 응답 구조**

모든 업로드 단계에서 응답은 아래 공통 구조를 따릅니다.

```json
{
  "msg_type": "IMAGE_RESPONSE",
  "msg_ver": 20241028,
  "msg_id": 1730011028000,
  "moid": {
	  "2.RTE058.4": {
		  "action": "response_action",
		  "status": "success",
		  "code": 200,
		  "message": "Descriptive response message",
		  "details": {
		    "chunk_index": 1,
		    "total_chunks": 83
		  }
	  }
  }
}
```

- `response_action`: 응답과 관련된 작업(`start`, `data`, `end` 등).
- `details`: 작업에 대한 추가 정보를 포함(예: 청크 번호).


## **5.3. 이미지 스케줄 프로토콜**

### **5.3.1. 스케줄 등록**

업로드된 이미지를 전광판에 표출하도록 스케줄을 등록합니다.

#### **요청 메시지**

```json
{
  "msg_type": "SCHEDULE",
  "msg_ver": 20241028,
  "msg_id": 1730011028000,
  "moid": {
	  "2.RTE058.5": {
		  "action": "set",
      "schedule": [
        {
          "image_id": "12345",
          "filename": "example_image.bmp",
          "effect": "fade_in",
          "parameters": {
            "1": 500,
            "2": 1000,
            "3": 20,
            "4": 1000
          },
          "schedule_time": {
            "start": "2025-01-15T08:00:00Z",
            "end": "2025-01-15T20:00:00Z"
          }
        }
      ]
    }
  }
}
```

|필드명|설명|
|---|---|
|`schedule`|이미지 스케줄 목록|
|`image_id`|이미지 고유 ID|
|`effect`|이미지 효과|
|`parameters`|효과 속성 (`1`: 반복 간격, `2`: 유지 시간 등)|
|`schedule_time`|스케줄 시작 및 종료 시간|


### **5.3.2. 스케줄 조회**

현재 등록된 스케줄 정보를 요청합니다.

#### **요청 메시지**

```json
{
  "msg_type": "SCHEDULE",
  "msg_ver": 20241028,
  "msg_id": 1730011028000,
  "moid": {
	  "2.RTE058.5": {
		  "action": "get"
	  }
  }
}
```


### **5.3.3. 스케줄 조회 응답**

등록된 스케줄 정보를 반환합니다.

#### **응답 메시지**

```json
{
  "msg_type": "SCHEDULE",
  "msg_ver": 20241028,
  "msg_id": 1730011028000,
  "moid": {
	  "2.RTE058.5": {
		  "action": "get_response",
		  "status": "success",
		  "code": 0,
		  "message": "Current schedule retrieved successfully",
      "schedule": [
        {
          "image_id": "12345",
          "filename": "example_image.bmp",
          "effect": "fade_in",
          "parameters": {
            "1": 500,
            "2": 1000,
            "3": 20,
            "4": 1000
          },
          "schedule_time": {
            "start": "2025-01-15T08:00:00Z",
            "end": "2025-01-15T20:00:00Z"
          }
        }
      ]
    }
  }
}
```



### **5.3.4. 스케줄 삭제**

특정 스케줄을 삭제하거나 모든 스케줄을 초기화합니다.

#### **요청 메시지**

```json
{
  "msg_type": "SCHEDULE",
  "msg_ver": 20241028,
  "msg_id": 1730011028000,
  "moid": {
	  "2.RTE058.5": {
		  "action": "delete",
		  "delete_all": false,
		  "image_ids": ["12345"]
	  }
  }
}
```

#### **응답 메시지**

```json
{
  "msg_type": "SCHEDULE",
  "msg_ver": 20241028,
  "msg_id": 1730011028000,
  "moid": {
	  "2.RTE058.5": {
		  "action": "delete_response",
		  "status": "success",
		  "code": 0,
		  "message": "Schedule deleted successfully",
		  "details": [
		    {
		      "image_id": "12345",
		      "status": "success",
		      "message": "Deleted"
		    }
		  ]
	  }
  }
}
```


## **5.4. 장점**

1. **일관성**: 업로드 및 스케줄 작업 모두 공통된 구조와 키를 사용.
2. **확장성**: 새로운 속성과 동작을 손쉽게 추가 가능.
3. **효율성**: 간결한 데이터 구조로 전송 속도와 파싱 속도 최적화.

---

## **6. 텍스트 메시지**
전광판에 텍스트를 표시하는 기능입니다.

- **실시간 문구**: 페이지 번호 `0`. 긴급 문구 등에 사용.
- **페이지 문구**: 페이지 번호 `1` 이상. 일반 안내문 등에 사용.

### **6.1. 실시간 문구(Real-time Text) 예제**

```json
{
  "MSG_TYPE": "TEXT",
  "MSG_VER": 20241028,
  "MSG_ID": 1730011021000,
  "MOID": {
    "2.RTE058.6.0.1.1": [1, 99],
    "2.RTE058.6.0.1.2": [20, 20, 10, 2],
    "2.RTE058.6.0.1.3": [0, 0, 0, 0],
    "2.RTE058.6.0.1.4": 1,
    "2.RTE058.6.0.1.5": [
      ["보행자", 1, 0, 0],
      ["주의", 3],
      ["바랍니다"]
    ]
  }
}
```

- **`MSG_TYPE`:** `"TEXT"`.
- **`MOID`:** `"2.RTE058.6.0.1"` → 전광판 RTE058, 텍스트 섹션(`"6"`), 페이지=0(실시간), 섹션=1.
    - `.1`(`"2.RTE058.6.0.1.1"`): `[1, 99]` → **표시방법=1**(즉시), **반복=99**(무한).
    - `.2`: `[20, 0, 10, 2]` → **입장효과=20**(좌로 이동), **퇴장=20**, **속도=10**, **유지=2초**.
    - `.3`: `[0, 0, 0, 0]` → 텍스트 표시 영역(전체 화면).
    - `.4`: `1` → 배경(또는 예약) 이미지 번호.
    - `.5`: 2차원 배열(텍스트들). 예: `"보행자"`, `"주의"`, `"바랍니다"`에 대한 색상/폰트 옵션 등.

#### **TEXT_RESPONSE(JSON)**

```json
{
  "MSG_TYPE": "TEXT_RESPONSE",
  "MSG_VER": 20241028,
  "MSG_ID": 1730011021000,
  "RESULT_CODE": 0,
  "RESULT_MSG": "OK",
  "RESULT": {
    "2.RTE058.6.0.1": 0
  }
}
```

- `MSG_TYPE="TEXT_RESPONSE"`, `MSG_ID`=`1730011021000`.
- `"2.RTE058.6.0.1": 0` → 실시간 문구 설정 성공(0=정상).

---

### **6.2. 페이지 문구(Page Text) 예제**

```json
{
  "MSG_TYPE": "TEXT",
  "MSG_VER": 20241028,
  "MSG_ID": 1730011022000,
  "MOID": {
    "2.RTE058.6.1.1.1": [1, 5],
    "2.RTE058.6.1.1.2": [30, 10, 15, 3],
    "2.RTE058.6.1.1.3": [0, 96, 0, 32],
    "2.RTE058.6.1.1.4": 2,
    "2.RTE058.6.1.1.5": [
      ["안전", 2, 0, 0],
      ["확인", 4],
      ["부탁드립니다"]
    ]
  }
}
```

- `"2.RTE058.6.1.2"` → 페이지=1, 섹션=1.
- **`.1`:** `[1,5]` → 표시방법=1(즉시), 5회 반복.
- **`.2`:** `[30,0,40,15]` → 입장=30(깜빡임), 퇴장=10(정지), 속도=15, 유지=3초.
- **`.3`:** `[0,96,0,32]` → 좌표 범위(X=0 ~ 96pixel, Y=0 ~ 32pixel).
- **`.4`:** `2` → 배경 이미지 번호=2.
- **`.5`:** 텍스트 배열(“안전”, “확인”, “부탁드립니다”).

#### **TEXT_RESPONSE(JSON)**

```json
{
  "MSG_TYPE": "TEXT_RESPONSE",
  "MSG_VER": 20241028,
  "MSG_ID": 1730011022000,
  "RESULT_CODE": 0,
  "RESULT_MSG": "OK",
  "RESULT": {
    "2.RTE058.6.1.1": 0
  }
}
```

- `"2.RTE058.6.1.1": 0` → 페이지=1, 섹션=2 문구 설정 성공.

---

### **6.3. 페이지 메시지 갯수 설정**
```json
{
  "MSG_TYPE": "SET",
  "MSG_VER": 20241028,
  "MSG_ID": 1730011028000,
  "MOID": {
    "2.RTE058.3.5": 5
  }
}
```

- `"2.RTE058.3.5": 5` → 페이지 문구를 최대 5개까지 사용 가능.

#### **SET_RESPONSE(JSON)**
```json
{
  "MSG_TYPE": "SET_RESPONSE",
  "MSG_VER": 20241028,
  "MSG_ID": 1730011028000,
  "RESULT_CODE": 0,
  "RESULT_MSG": "OK",
  "RESULT": {
    "2.RTE058.3.5": 0
  }
}
```

- 성공 시 `"2.RTE058.3.5": 0`.


---

## **부록1. 폰트 데이터 전송 & 펌웨어 업데이트**
- `/msg` 토픽으로 전송하고, `/msg_r` 토픽으로 응답을 받습니다.
- 전송 형식(`db_asc`, `db_hex`)에 따라 Base64 적용 여부가 달라집니다.
    - **`db_asc`**: Base64 미적용, **ASCII** 데이터 전송
    - **`db_hex`**: **Base64 인코딩**된 HEX 데이터 전송

### `db_asc` 예
```text
[DB] MQTT Sub: /msg{"db_asc":"![00211!]"}
[DB] RS232 Send(ASCII): ![00211!]
[DB] RS232 Resp(ASCII): ![00210!]
[DB] MQTT Pub: /msg_r{"db_asc":"![00210!]"}
```

- **내용 설명**:
    - `/msg` 토픽 구독 시, ASCII 프로토콜 데이터(`![00211!]`)를 수신(`db_asc` 키).
    - 내부적으로 RS232(ASCII)로 디바이스에 전송 후 응답(`![00210!]`)을 다시 `/msg_r` 토픽에 **Publish**.

### `db_hex` 예
```text
[DB] MQTT Sub: /msg{"db_hex":"EAIAAAJBARAD"}
[DB] RS232 Send(HEX): 10 02 00 00 02 41 01 10 03
[DB] RS232 Resp(HEX): 10 02 00 00 02 41 00 10 03
[DB] MQTT Pub: /msg_r{"db_hex":"EAIAAAJBABAD"}
```

- **내용 설명**:
    - `/msg` 토픽 구독 시, Base64(HEX) 데이터를 (`EAIAAAJBARAD`) 수신(`db_hex` 키).
    - 이를 RS232(HEX)로 디바이스에 전송하고, 그 응답을 다시 Base64(HEX) 형태로 `/msg_r` 토픽에 **Publish**.